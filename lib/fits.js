// Generated by CoffeeScript 1.4.0
(function() {
  var BinaryTable, CompressedImage, DataUnit, Decompress, FITS, File, HDU, Header, HeaderVerify, Image, ImageUtils, Module, Table, Tabular, moduleKeywords,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if (this.astro == null) {
    this.astro = {};
  }

  FITS = {};

  FITS.version = '0.3.1';

  this.astro.FITS = FITS;

  moduleKeywords = ['included', 'extended'];

  Module = (function() {

    function Module() {}

    Module.include = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'include(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((_ref = obj.included) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.extend = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'extend(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((_ref = obj.extended) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    Module.prototype.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    return Module;

  })();

  this.astro.FITS.Module = Module;

  DataUnit = (function(_super) {

    __extends(DataUnit, _super);

    DataUnit.prototype.swapEndian = {
      B: function(value) {
        return value;
      },
      I: function(value) {
        return (value << 8) | (value >> 8);
      },
      J: function(value) {
        return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);
      }
    };

    DataUnit.prototype.swapEndian[8] = DataUnit.prototype.swapEndian['B'];

    DataUnit.prototype.swapEndian[16] = DataUnit.prototype.swapEndian['I'];

    DataUnit.prototype.swapEndian[32] = DataUnit.prototype.swapEndian['J'];

    function DataUnit(header, view, offset) {
      this.view = view;
      this.offset = offset;
      this.begin = this.offset;
    }

    return DataUnit;

  })(Module);

  this.astro.FITS.DataUnit = DataUnit;

  HeaderVerify = {
    verifyOrder: function(keyword, order) {
      if (order !== this.cardIndex) {
        return console.warn("" + keyword + " should appear at index " + this.cardIndex + " in the FITS header");
      }
    },
    verifyBetween: function(keyword, value, lower, upper) {
      if (!(value >= lower && value <= upper)) {
        throw "The " + keyword + " value of " + value + " is not between " + lower + " and " + upper;
      }
    },
    verifyBoolean: function(value) {
      if (value === "T") {
        return true;
      } else {
        return false;
      }
    },
    VerifyFns: {
      SIMPLE: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.primary = true;
        this.verifyOrder("SIMPLE", 0);
        return this.verifyBoolean(value);
      },
      XTENSION: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        this.extension = true;
        this.extensionType = arguments[0];
        this.verifyOrder("XTENSION", 0);
        return this.extensionType;
      },
      BITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BITPIX";
        value = parseInt(arguments[0]);
        this.verifyOrder(key, 1);
        if (value !== 8 && value !== 16 && value !== 32 && value !== (-32)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return value;
      },
      NAXIS: function() {
        var args, array, key, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "NAXIS";
        value = parseInt(arguments[0]);
        array = arguments[1];
        if (!array) {
          this.verifyOrder(key, 2);
          this.verifyBetween(key, value, 0, 999);
          if (this.isExtension()) {
            if ((_ref = this.extensionType) === "TABLE" || _ref === "BINTABLE") {
              required = 2;
              if (value !== required) {
                throw "" + key + " must be " + required + " for TABLE and BINTABLE extensions";
              }
            }
          }
        }
        return value;
      },
      PCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "PCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this.get("NAXIS");
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE") {
            required = 0;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      GCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "GCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this.get("NAXIS") + 1;
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE" || _ref === "BINTABLE") {
            required = 1;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      EXTEND: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        if (!this.isPrimary()) {
          throw "EXTEND must only appear in the primary header";
        }
        return this.verifyBoolean(value);
      },
      BSCALE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BZERO: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BLANK: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        if (!(this.get("BIXPIX") > 0)) {
          throw "BLANK is not to be used for BITPIX = " + (this.get('BITPIX'));
        }
        return parseInt(value);
      },
      DATAMIN: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      DATAMAX: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      EXTVER: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseInt(arguments[0]);
      },
      EXTLEVEL: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseInt(arguments[0]);
      },
      TFIELDS: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = parseInt(arguments[0]);
        this.verifyBetween("TFIELDS", value, 0, 999);
        return value;
      },
      TBCOL: function() {
        var args, index, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        index = arguments[2];
        this.verifyBetween("TBCOL", index, 0, this.get("TFIELDS"));
        return value;
      },
      ZIMAGE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return this.verifyBoolean(arguments[0]);
      },
      ZCMPTYPE: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        if (value !== 'GZIP_1' && value !== 'RICE_1' && value !== 'PLIO_1' && value !== 'HCOMPRESS_1') {
          throw "ZCMPTYPE value " + value + " is not permitted";
        }
        if (value !== 'RICE_1') {
          throw "Compress type " + value + " is not yet implement";
        }
        return value;
      },
      ZBITPIX: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = parseInt(arguments[0]);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "ZBITPIX value " + value + " is not permitted";
        }
        return value;
      },
      ZNAXIS: function() {
        var args, array, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = parseInt(arguments[0]);
        array = arguments[1];
        value = value;
        if (!array) {
          this.verifyBetween("ZNAXIS", value, 0, 999);
        }
        return value;
      },
      ZTILE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseInt(arguments[0]);
      },
      ZSIMPLE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (arguments[0] === "T") {
          return true;
        } else {
          return false;
        }
      },
      ZPCOUNT: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseInt(arguments[0]);
      },
      ZGCOUNT: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseInt(arguments[0]);
      }
    }
  };

  this.astro.FITS.HeaderVerify = HeaderVerify;

  Header = (function(_super) {

    __extends(Header, _super);

    Header.include(HeaderVerify);

    Header.prototype.arrayPattern = /(\D+)(\d+)/;

    Header.prototype.maxLines = 600;

    function Header(block) {
      this.readBlock = __bind(this.readBlock, this);

      var method, name, _ref;
      this.primary = false;
      this.extension = false;
      this.verifyCard = {};
      _ref = this.VerifyFns;
      for (name in _ref) {
        method = _ref[name];
        this.verifyCard[name] = this.proxy(method);
      }
      this.cards = {};
      this.cards["COMMENT"] = [];
      this.cards["HISTORY"] = [];
      this.cardIndex = 0;
      this.readBlock(block);
    }

    Header.prototype.get = function(key) {
      if (this.contains(key)) {
        return this.cards[key].value;
      } else {
        return null;
      }
    };

    Header.prototype.set = function(key, value, comment) {
      comment = comment || '';
      this.cards[key] = {
        index: this.cardIndex,
        value: value,
        comment: comment
      };
      return this.cardIndex += 1;
    };

    Header.prototype.contains = function(key) {
      return this.cards.hasOwnProperty(key);
    };

    Header.prototype.readLine = function(l) {
      var blank, comment, firstByte, indicator, key, value, _ref;
      key = l.slice(0, 8).trim();
      blank = key === '';
      if (blank) {
        return;
      }
      indicator = l.slice(8, 10);
      value = l.slice(10);
      if (indicator !== "= ") {
        if (key === 'COMMENT' || key === 'HISTORY') {
          this.cards[key].push(value.trim());
        }
        return;
      }
      _ref = value.split(' /'), value = _ref[0], comment = _ref[1];
      value = value.trim();
      firstByte = value[0];
      if (firstByte === "'") {
        value = value.slice(1, -1).trim();
      } else {
        if (value !== 'T' && value !== 'F') {
          value = parseFloat(value);
        }
      }
      value = this.validate(key, value);
      return this.set(key, value, comment);
    };

    Header.prototype.validate = function(key, value) {
      var baseKey, index, isArray, match, _ref;
      index = null;
      baseKey = key;
      isArray = this.arrayPattern.test(key);
      if (isArray) {
        match = this.arrayPattern.exec(key);
        _ref = match.slice(1), baseKey = _ref[0], index = _ref[1];
      }
      if (baseKey in this.verifyCard) {
        value = this.verifyCard[baseKey](value, isArray, index);
      }
      return value;
    };

    Header.prototype.readBlock = function(block) {
      var i, line, lineWidth, nLines, _i, _ref, _results;
      lineWidth = 80;
      nLines = block.length / lineWidth;
      nLines = nLines < this.maxLines ? nLines : this.maxLines;
      _results = [];
      for (i = _i = 0, _ref = nLines - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = block.slice(i * lineWidth, (i + 1) * lineWidth);
        _results.push(this.readLine(line));
      }
      return _results;
    };

    Header.prototype.hasDataUnit = function() {
      if (this.get("NAXIS") === 0) {
        return false;
      } else {
        return true;
      }
    };

    Header.prototype.isPrimary = function() {
      return this.primary;
    };

    Header.prototype.isExtension = function() {
      return this.extension;
    };

    return Header;

  })(Module);

  this.astro.FITS.Header = Header;

  ImageUtils = {
    getExtent: function(arr) {
      var index, max, min, value, _ref, _ref1;
      if ((this.min != null) && (this.max != null)) {
        return [this.min, this.max];
      }
      index = arr.length;
      while (index--) {
        value = arr[index];
        if (isNaN(value)) {
          continue;
        }
        _ref = [value, value], min = _ref[0], max = _ref[1];
        break;
      }
      while (index--) {
        value = arr[index];
        if (isNaN(value)) {
          continue;
        }
        if (value < min) {
          min = value;
        }
        if (value > max) {
          max = value;
        }
      }
      _ref1 = [min, max], this.min = _ref1[0], this.max = _ref1[1];
      return [this.min, this.max];
    },
    getPixel: function(arr, x, y) {
      return arr[y * this.width + x];
    }
  };

  this.astro.FITS.ImageUtils = ImageUtils;

  Image = (function(_super) {

    __extends(Image, _super);

    Image.include(ImageUtils);

    function Image(header, view, offset) {
      var i, naxis, _i;
      Image.__super__.constructor.apply(this, arguments);
      naxis = header.get("NAXIS");
      this.bitpix = header.get("BITPIX");
      this.naxis = [];
      for (i = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; i = 1 <= naxis ? ++_i : --_i) {
        this.naxis.push(header.get("NAXIS" + i));
      }
      this.width = header.get("NAXIS1");
      this.height = header.get("NAXIS2") || 1;
      this.bzero = header.get("BZERO") || 0;
      this.bscale = header.get("BSCALE") || 1;
      this.bytes = Math.abs(this.bitpix) / 8;
      this.length = this.naxis.reduce(function(a, b) {
        return a * b;
      }) * Math.abs(this.bitpix) / 8;
      this.frame = 0;
    }

    Image.prototype.getFrameAsync = function(frame, callback) {
      var URL, blob, blobUrl, data, fn, nPixels, onmessage, start, worker;
      this.frame = frame != null ? frame : this.frame;
      onmessage = function(e) {
        var arr, bitpix, bscale, bzero, chunk, data, height, i, nPixels, swapEndian, value, width;
        data = e.data;
        bitpix = data.bitpix;
        width = data.width;
        height = data.height;
        bzero = data.bzero;
        bscale = data.bscale;
        chunk = data.chunk;
        nPixels = i = width * height;
        switch (Math.abs(bitpix)) {
          case 16:
            swapEndian = function(value) {
              return (value << 8) | (value >> 8);
            };
            break;
          case 32:
            swapEndian = function(value) {
              return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);
            };
            break;
          default:
            swapEndian = function(value) {
              return value;
            };
        }
        if (bitpix > 0) {
          switch (bitpix) {
            case 8:
              arr = new Uint8Array(chunk);
              arr = new Uint16Array(arr);
              break;
            case 16:
              arr = new Uint16Array(chunk);
              break;
            case 32:
              arr = new Int32Array(chunk);
          }
          while (nPixels--) {
            value = arr[nPixels];
            value = swapEndian(value);
            arr[nPixels] = bzero + bscale * value + 0.5;
          }
        } else {
          arr = new Uint32Array(chunk);
          while (i--) {
            value = arr[i];
            arr[i] = swapEndian(value);
          }
          arr = new Float32Array(chunk);
          while (nPixels--) {
            arr[nPixels] = bzero + bscale * arr[nPixels];
          }
        }
        return postMessage(arr);
      };
      fn = onmessage.toString().split('').reverse().join('').replace(' nruter', '');
      fn = fn.split('').reverse().join('');
      fn = "onmessage = " + fn;
      blob = new Blob([fn], {
        type: "application/javascript"
      });
      URL = URL || webkitURL;
      blobUrl = URL.createObjectURL(blob);
      worker = new Worker(blobUrl);
      worker.onmessage = function(e) {
        var arr;
        arr = e.data;
        if (callback != null) {
          callback.call(this, arr);
        }
        return URL.revokeObjectURL(blobUrl);
      };
      nPixels = this.width * this.height;
      start = this.offset + (this.frame * nPixels * this.bytes);
      data = {};
      data.bitpix = this.bitpix;
      data.width = this.width;
      data.height = this.height;
      data.bzero = this.bzero;
      data.bscale = this.bscale;
      data.chunk = this.view.buffer.slice(start, start + nPixels * this.bytes);
      return worker.postMessage(data);
    };

    Image.prototype.getFrame = function(frame) {
      var arr, bitpix, buffer, chunk, i, nPixels, start, value;
      this.frame = frame != null ? frame : this.frame;
      buffer = this.view.buffer;
      nPixels = i = this.width * this.height;
      start = this.offset + (this.frame * nPixels * this.bytes);
      chunk = buffer.slice(start, start + nPixels * this.bytes);
      bitpix = Math.abs(this.bitpix);
      if (this.bitpix > 0) {
        switch (this.bitpix) {
          case 8:
            arr = new Uint8Array(chunk);
            arr = new Uint16Array(arr);
            break;
          case 16:
            arr = new Uint16Array(chunk);
            break;
          case 32:
            arr = new Int32Array(chunk);
        }
        while (nPixels--) {
          value = arr[nPixels];
          value = this.swapEndian[bitpix](value);
          arr[nPixels] = this.bzero + this.bscale * value + 0.5;
        }
      } else {
        arr = new Uint32Array(chunk);
        while (i--) {
          value = arr[i];
          arr[i] = this.swapEndian[bitpix](value);
        }
        arr = new Float32Array(chunk);
        while (nPixels--) {
          arr[nPixels] = this.bzero + this.bscale * arr[nPixels];
        }
      }
      if (this.isDataCube()) {
        this.frame += 1;
      }
      return arr;
    };

    Image.prototype.isDataCube = function() {
      if (this.naxis.length > 2) {
        return true;
      } else {
        return false;
      }
    };

    return Image;

  })(DataUnit);

  this.astro.FITS.Image = Image;

  Tabular = (function(_super) {
    var _this = this;

    __extends(Tabular, _super);

    Tabular.prototype.typedArray = {
      B: Uint8Array,
      I: Uint16Array,
      J: Int32Array,
      E: Float32Array,
      D: Float64Array,
      1: Uint8Array,
      2: Uint16Array,
      4: Int32Array
    };

    Tabular.prototype.dataAccessors = {
      L: function(view, offset) {
        var val, x;
        x = view.getInt8(offset);
        offset += 1;
        val = x === 84 ? true : false;
        return [val, offset];
      },
      B: function(view, offset) {
        var val;
        val = view.getUint8(offset);
        offset += 1;
        return [val, offset];
      },
      I: function(view, offset) {
        var val;
        val = view.getInt16(offset);
        offset += 2;
        return [val, offset];
      },
      J: function(view, offset) {
        var val;
        val = view.getInt32(offset);
        offset += 4;
        return [val, offset];
      },
      K: function(view, offset) {
        var factor, highByte, lowByte, mod, val;
        highByte = Math.abs(view.getInt32(offset));
        offset += 4;
        lowByte = Math.abs(view.getInt32(offset));
        offset += 4;
        mod = highByte % 10;
        factor = mod ? -1 : 1;
        highByte -= mod;
        console.warn("Precision for 64 bit integers may be incorrect.");
        val = factor * ((highByte << 32) | lowByte);
        return [val, offset];
      },
      A: function(view, offset) {
        var val;
        val = view.getChar(offset);
        offset += 1;
        return [val, offset];
      },
      E: function(view, offset) {
        var val;
        val = view.getFloat32(offset);
        offset += 4;
        return [val, offset];
      },
      D: function(view, offset) {
        var val;
        val = view.getFloat64(offset);
        offset += 8;
        return [val, offset];
      },
      C: function(view, offset) {
        var val, val1, val2;
        val1 = view.getFloat32(offset);
        offset += 4;
        val2 = view.getFloat32(offset);
        offset += 4;
        val = [val1, val2];
        return [val, offset];
      },
      M: function(view, offset) {
        var val, val1, val2;
        val1 = view.getFloat64(offset);
        offset += 8;
        val2 = view.getFloat64(offset);
        offset += 8;
        val = [val1, val2];
        return [val, offset];
      }
    };

    function Tabular(header, view, offset) {
      this.getRow = __bind(this.getRow, this);
      Tabular.__super__.constructor.apply(this, arguments);
      this.rowByteSize = header.get("NAXIS1");
      this.rows = header.get("NAXIS2");
      this.cols = header.get("TFIELDS");
      this.length = this.rowByteSize * this.rows;
      this.rowsRead = 0;
      this.columns = this.getColumnNames(header);
      this.accessors = [];
    }

    Tabular.prototype.getRow = function(row) {
      var accessor, index, _i, _len, _ref;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.offset = this.begin + this.rowsRead * this.rowByteSize;
      row = {};
      _ref = this.accessors;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        accessor = _ref[index];
        row[this.columns[index]] = accessor();
      }
      this.rowsRead += 1;
      return row;
    };

    Tabular.prototype.getColumnNames = function(header) {
      var columnNames, i, key, _i, _ref;
      columnNames = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        key = "TTYPE" + i;
        if (!header.contains(key)) {
          return null;
        }
        columnNames.push(header.get(key));
      }
      return columnNames;
    };

    return Tabular;

  }).call(this, DataUnit);

  this.astro.FITS.Tabular = Tabular;

  Table = (function(_super) {

    __extends(Table, _super);

    Table.prototype.dataAccessors = {
      A: function(value) {
        return value.trim();
      },
      I: function(value) {
        return parseInt(value);
      },
      F: function(value) {
        return parseFloat(value);
      },
      E: function(value) {
        return parseFloat(value);
      },
      D: function(value) {
        return parseFloat(value);
      }
    };

    function Table(header, view, offset) {
      this.getRow = __bind(this.getRow, this);
      Table.__super__.constructor.apply(this, arguments);
      this.setAccessors(header);
    }

    Table.prototype.setAccessors = function(header) {
      var descriptor, form, i, match, pattern, type, _i, _ref, _results,
        _this = this;
      pattern = /([AIFED])(\d+)\.*(\d+)*/;
      _results = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        form = header.get("TFORM" + i);
        type = header.get("TTYPE" + i);
        match = pattern.exec(form);
        descriptor = match[1];
        _results.push((function(descriptor) {
          var accessor;
          accessor = function(value) {
            return _this.dataAccessors[descriptor](value);
          };
          return _this.accessors.push(accessor);
        })(descriptor));
      }
      return _results;
    };

    Table.prototype.getRow = function(row) {
      var index, line, value, _i, _len;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.offset = this.begin + this.rowsRead * this.rowByteSize;
      line = this.view.getString(this.offset, this.rowByteSize).trim().split(/\s+/);
      row = {};
      for (index = _i = 0, _len = line.length; _i < _len; index = ++_i) {
        value = line[index];
        row[this.columns[index]] = this.accessors[index](value);
      }
      this.offset += this.rowByteSize;
      this.rowsRead += 1;
      return row;
    };

    return Table;

  })(Tabular);

  this.astro.FITS.Table = Table;

  BinaryTable = (function(_super) {

    __extends(BinaryTable, _super);

    function BinaryTable(header, view, offset) {
      BinaryTable.__super__.constructor.apply(this, arguments);
      this.tableLength = this.length;
      this.columnNames = {};
      this.setAccessors(header);
    }

    BinaryTable.prototype.toBits = function(byte) {
      var arr, i;
      arr = [];
      i = 128;
      while (i >= 1) {
        arr.push((byte & i ? 1 : 0));
        i /= 2;
      }
      return arr;
    };

    BinaryTable.prototype.getFromHeap = function(descriptor) {
      var arr, chunk, heapOffset, i, length, offset;
      length = this.view.getInt32(this.offset);
      this.offset += 4;
      offset = this.view.getInt32(this.offset);
      this.offset += 4;
      heapOffset = this.begin + this.tableLength + offset;
      chunk = this.view.buffer.slice(heapOffset, heapOffset + length);
      arr = new this.typedArray[descriptor](chunk);
      i = arr.length;
      while (i--) {
        arr[i] = this.swapEndian[descriptor](arr[i]);
      }
      return arr;
    };

    BinaryTable.prototype.setAccessors = function(header) {
      var count, descriptor, form, i, isArray, match, pattern, type, _i, _ref, _results,
        _this = this;
      pattern = /(\d*)([P|Q]*)([L|X|B|I|J|K|A|E|D|C|M]{1})/;
      _results = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        form = header.get("TFORM" + i);
        type = header.get("TTYPE" + i);
        match = pattern.exec(form);
        count = parseInt(match[1]) || 1;
        isArray = match[2];
        descriptor = match[3];
        this.columnNames[type] = i - 1;
        if (isArray) {
          switch (type) {
            case "COMPRESSED_DATA":
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  var arr, pixels;
                  arr = _this.getFromHeap(descriptor);
                  pixels = new _this.typedArray[_this.params["BYTEPIX"]](_this.ztile[0]);
                  _this.constructor.Rice(arr, _this.params["BLOCKSIZE"], _this.params["BYTEPIX"], pixels, _this.ztile[0]);
                  return pixels;
                };
                return _this.accessors.push(accessor);
              })(descriptor, count));
              break;
            case "GZIP_COMPRESSED_DATA":
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  var arr;
                  arr = new Float32Array(_this.width);
                  i = arr.length;
                  while (i--) {
                    arr[i] = NaN;
                  }
                  return arr;
                };
                return _this.accessors.push('accessor');
              })(descriptor, count));
              break;
            default:
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  return _this.getFromHeap(descriptor);
                };
                return _this.accessors.push('accessor');
              })(descriptor, count));
          }
        } else {
          if (count === 1) {
            _results.push((function(descriptor, count) {
              var accessor;
              accessor = function() {
                var value, _ref1;
                _ref1 = _this.dataAccessors[descriptor](_this.view, _this.offset), value = _ref1[0], _this.offset = _ref1[1];
                return value;
              };
              return _this.accessors.push(accessor);
            })(descriptor, count));
          } else {
            if (descriptor === 'X') {
              _results.push((function(descriptor, count) {
                var accessor, nBytes;
                nBytes = Math.log(count) / Math.log(2);
                accessor = function() {
                  var arr, bits, byte, bytes, chunk, _j, _len;
                  chunk = _this.view.buffer.slice(_this.offset, _this.offset + nBytes);
                  bytes = new Uint8Array(chunk);
                  bits = [];
                  for (_j = 0, _len = bytes.length; _j < _len; _j++) {
                    byte = bytes[_j];
                    arr = _this.toBits(byte);
                    bits = bits.concat(arr);
                  }
                  _this.offset += nBytes;
                  return bits.slice(0, +(count - 1) + 1 || 9e9);
                };
                return _this.accessors.push(accessor);
              })(descriptor, count));
            } else if (descriptor === 'A') {
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  var str;
                  str = _this.view.getString(_this.offset, count);
                  _this.offset += count;
                  return str.trim();
                };
                return _this.accessors.push(accessor);
              })(descriptor, count));
            } else {
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  var data, value, _ref1;
                  data = [];
                  while (count--) {
                    _ref1 = _this.dataAccessors[descriptor](_this.view, _this.offset), value = _ref1[0], _this.offset = _ref1[1];
                    data.push(value);
                  }
                  return data;
                };
                return _this.accessors.push(accessor);
              })(descriptor, count));
            }
          }
        }
      }
      return _results;
    };

    return BinaryTable;

  })(Tabular);

  this.astro.FITS.BinaryTable = BinaryTable;

  Decompress = {
    Rice: function(array, blocksize, bytepix, pixels, nx) {
      var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer, _ref, _ref1;
      bbits = 1 << fsbits;
      _ref = this.RiceSetup[bytepix](array), fsbits = _ref[0], fsmax = _ref[1], lastpix = _ref[2], pointer = _ref[3];
      nonzeroCount = new Uint8Array(256);
      nzero = 8;
      _ref1 = [128, 255], k = _ref1[0], i = _ref1[1];
      while (i >= 0) {
        while (i >= k) {
          nonzeroCount[i] = nzero;
          i -= 1;
        }
        k = k / 2;
        nzero -= 1;
      }
      nonzeroCount[0] = 0;
      b = array[pointer];
      pointer += 1;
      nbits = 8;
      i = 0;
      while (i < nx) {
        nbits -= fsbits;
        while (nbits < 0) {
          b = (b << 8) | array[pointer];
          pointer += 1;
          nbits += 8;
        }
        fs = (b >> nbits) - 1;
        b &= (1 << nbits) - 1;
        imax = i + blocksize;
        if (imax > nx) {
          imax = nx;
        }
        if (fs < 0) {
          while (i < imax) {
            array[i] = lastpix;
            i++;
          }
        } else if (fs === fsmax) {
          while (i < imax) {
            k = bbits - nbits;
            diff = b << k;
            k -= 8;
            while (k >= 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b << k;
              k -= 8;
            }
            if (nbits > 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b >> (-k);
              b &= (1 << nbits) - 1;
            } else {
              b = 0;
            }
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            array[i] = diff + lastpix;
            lastpix = array[i];
            i++;
          }
        } else {
          while (i < imax) {
            while (b === 0) {
              nbits += 8;
              b = array[pointer];
              pointer += 1;
            }
            nzero = nbits - nonzeroCount[b];
            nbits -= nzero + 1;
            b ^= 1 << nbits;
            nbits -= fs;
            while (nbits < 0) {
              b = (b << 8) | array[pointer];
              pointer += 1;
              nbits += 8;
            }
            diff = (nzero << fs) | (b >> nbits);
            b &= (1 << nbits) - 1;
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            pixels[i] = diff + lastpix;
            lastpix = pixels[i];
            i++;
          }
        }
      }
      return pixels;
    },
    RiceSetup: {
      1: function(array) {
        var fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 3;
        fsmax = 6;
        lastpix = array[pointer];
        pointer += 1;
        return [fsbits, fsmax, lastpix, pointer];
      },
      2: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 4;
        fsmax = 14;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      },
      4: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 5;
        fsmax = 25;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 24);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 16);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      }
    },
    gzip: function(array) {
      throw "Not yet implemented";
    },
    plio: function(array, length) {
      throw "Not yet implemented";
    },
    hcompress: function(array, length) {
      throw "Not yet implemented";
    }
  };

  this.astro.FITS.Decompress = Decompress;

  CompressedImage = (function(_super) {

    __extends(CompressedImage, _super);

    CompressedImage.include(ImageUtils);

    CompressedImage.extend(Decompress);

    function CompressedImage(header, view, offset) {
      var i, key, value, ztile, _i, _ref;
      CompressedImage.__super__.constructor.apply(this, arguments);
      this.length += header.get("PCOUNT");
      this.zcmptype = header.get("ZCMPTYPE");
      this.zbitpix = header.get("ZBITPIX");
      this.znaxis = header.get("ZNAXIS");
      this.zblank = this.getValue(header, "ZBLANK", void 0);
      this.blank = this.getValue(header, "BLANK", void 0);
      this.ztile = [];
      for (i = _i = 1, _ref = this.znaxis; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        ztile = header.contains("ZTILE" + i) ? header.get("ZTILE" + i) : i === 1 ? header.get("ZNAXIS1") : 1;
        this.ztile.push(ztile);
      }
      this.width = header.get("ZNAXIS1");
      this.height = header.get("ZNAXIS2") || 1;
      this.params = {};
      i = 1;
      while (true) {
        key = "ZNAME" + i;
        if (!header.contains(key)) {
          break;
        }
        value = "ZVAL" + i;
        this.params[header.get(key)] = header.get(value);
        i += 1;
      }
      if (this.zcmptype === 'RICE_1') {
        this.setRiceDefaults();
      }
      this.zmaskcmp = this.getValue(header, "ZMASKCMP", void 0);
      this.zquantiz = this.getValue(header, "ZQUANTIZ", "LINEAR_SCALING");
      this.bzero = this.getValue(header, "BZERO", 0);
      this.bscale = this.getValue(header, "BSCALE", 1);
      this.setAccessors(header);
      this.defGetRow();
    }

    CompressedImage.prototype.getValue = function(header, key, defaultValue) {
      if (header.contains(key)) {
        return header.get(key);
      } else {
        return defaultValue;
      }
    };

    CompressedImage.prototype.setRiceDefaults = function() {
      if (!("BLOCKSIZE" in this.params)) {
        this.params["BLOCKSIZE"] = 32;
      }
      if (!("BYTEPIX" in this.params)) {
        return this.params["BYTEPIX"] = 4;
      }
    };

    CompressedImage.prototype.defGetRow = function() {
      var hasBlanks;
      hasBlanks = (this.zblank != null) || (this.blank != null) || this.columnNames.hasOwnProperty("ZBLANK");
      return this.getRow = hasBlanks ? this.getRowHasBlanks : this.getRowNoBlanks;
    };

    CompressedImage.prototype.getRowHasBlanks = function(arr) {
      var blank, data, i, index, offset, scale, value, zero, _i, _len, _ref;
      _ref = this.getTableRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      offset = this.rowsRead * this.width;
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        i = offset + index;
        arr[i] = value === blank ? NaN : zero + scale * value;
      }
      return this.rowsRead += 1;
    };

    CompressedImage.prototype.getRowNoBlanks = function(arr) {
      var blank, data, i, index, offset, scale, value, zero, _i, _len, _ref;
      _ref = this.getTableRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      offset = this.rowsRead * this.width;
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        i = offset + index;
        arr[i] = zero + scale * value;
      }
      return this.rowsRead += 1;
    };

    CompressedImage.prototype.getTableRow = function() {
      var accessor, blank, data, row, scale, zero, _i, _len, _ref;
      this.offset = this.begin + this.rowsRead * this.rowByteSize;
      row = [];
      _ref = this.accessors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        accessor = _ref[_i];
        row.push(accessor());
      }
      data = row[this.columnNames["COMPRESSED_DATA"]] || row[this.columnNames["UNCOMPRESSED_DATA"]] || row[this.columnNames["GZIP_COMPRESSED_DATA"]];
      blank = row[this.columnNames["ZBLANK"]] || this.zblank;
      scale = row[this.columnNames["ZSCALE"]] || this.bscale;
      zero = row[this.columnNames["ZZERO"]] || this.bzero;
      return [data, blank, scale, zero];
    };

    CompressedImage.prototype.getFrame = function() {
      var arr, height;
      arr = new Float32Array(this.width * this.height);
      this.rowsRead = 0;
      height = this.height;
      while (height--) {
        this.getRow(arr);
      }
      return arr;
    };

    return CompressedImage;

  })(BinaryTable);

  this.astro.FITS.CompressedImage = CompressedImage;

  HDU = (function() {

    function HDU(header, data) {
      this.header = header;
      this.data = data;
    }

    HDU.prototype.hasData = function() {
      if (this.data != null) {
        return true;
      } else {
        return false;
      }
    };

    HDU.prototype.getCard = function(key) {
      return this.header.get(key);
    };

    return HDU;

  })();

  this.astro.FITS.HDU = HDU;

  File = (function() {

    File.prototype.LINEWIDTH = 80;

    File.prototype.BLOCKLENGTH = 2880;

    function File(arg, callback) {
      this.isEOF = __bind(this.isEOF, this);

      this.excessBytes = __bind(this.excessBytes, this);

      var xhr,
        _this = this;
      this.constructor.extendDataView(this.view);
      this.hdus = [];
      this.offset = 0;
      if (typeof arg === 'string') {
        xhr = new XMLHttpRequest();
        xhr.open('GET', arg);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function() {
          return _this.initBuffer(xhr.response, callback);
        };
        xhr.send();
      } else {
        this.initBuffer(arg);
      }
    }

    File.prototype.initBuffer = function(buffer, callback) {
      var data, hdu, header;
      this.length = buffer.byteLength;
      this.view = new DataView(buffer);
      while (true) {
        header = this.readHeader();
        data = this.readData(header);
        hdu = new HDU(header, data);
        this.hdus.push(hdu);
        if (this.isEOF()) {
          break;
        }
      }
      if (callback != null) {
        return callback.call(this, this);
      }
    };

    File.extendDataView = function(view) {
      DataView.prototype.getString = function(offset, length) {
        var c, value;
        value = '';
        while (length--) {
          c = this.getUint8(offset);
          offset += 1;
          value += String.fromCharCode(c > 127 ? 65533 : c);
        }
        return value;
      };
      return DataView.prototype.getChar = function(offset) {
        return this.getString(offset, 1);
      };
    };

    File.prototype.excessBytes = function(length) {
      return (this.BLOCKLENGTH - (length % this.BLOCKLENGTH)) % this.BLOCKLENGTH;
    };

    File.prototype.readHeader = function() {
      var begin, beginOffset, block, end, endOffset, endPattern, i, line, match;
      endPattern = /^END\s/;
      beginOffset = this.offset;
      while (true) {
        block = this.view.getString(this.offset, this.BLOCKLENGTH);
        this.offset += this.BLOCKLENGTH;
        i = 1;
        while (true) {
          begin = this.BLOCKLENGTH - this.LINEWIDTH * i;
          end = begin + this.LINEWIDTH;
          line = block.slice(begin, end);
          match = /\s{80}/.test(line);
          if (match) {
            i += 1;
            continue;
          }
          match = /^END\s/.test(line);
          if (match) {
            endOffset = this.offset;
            block = this.view.getString(beginOffset, endOffset - beginOffset);
            return new Header(block);
          }
          break;
        }
      }
    };

    File.prototype.readData = function(header) {
      var DU, data, excess;
      if (!header.hasDataUnit()) {
        return;
      }
      if (header.isPrimary()) {
        DU = Image;
      } else if (header.isExtension()) {
        if (header.extensionType === "BINTABLE") {
          if (header.contains("ZIMAGE")) {
            DU = CompressedImage;
          } else {
            DU = BinaryTable;
          }
        } else if (header.extensionType === "TABLE") {
          DU = Table;
        } else if (header.extensionType === "IMAGE") {
          DU = Image;
        }
      }
      data = new DU(header, this.view, this.offset);
      excess = this.excessBytes(data.length);
      this.offset += data.length + excess;
      return data;
    };

    File.prototype.isEOF = function() {
      if (this.offset === this.length) {
        return true;
      } else {
        return false;
      }
    };

    File.prototype.getHDU = function(index) {
      var hdu, _i, _len, _ref;
      if ((index != null) && (this.hdus[index] != null)) {
        return this.hdus[index];
      }
      _ref = this.hdus;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hdu = _ref[_i];
        if (hdu.hasData()) {
          return hdu;
        }
      }
    };

    File.prototype.getHeader = function(index) {
      return this.getHDU(index).header;
    };

    File.prototype.getDataUnit = function(index) {
      return this.getHDU(index).data;
    };

    File.prototype.getData = function(index) {
      return this.getHDU(index).data.getFrame();
    };

    return File;

  })();

  this.astro.FITS.File = File;

}).call(this);
