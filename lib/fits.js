
(function(/*! Stitch !*/) {
  if (!this.require) {
    var modules = {}, cache = {}, require = function(name, root) {
      var path = expand(root, name), module = cache[path], fn;
      if (module) {
        return module.exports;
      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {
        module = {id: path, exports: {}};
        try {
          cache[path] = module;
          fn(module.exports, function(name) {
            return require(name, dirname(path));
          }, module);
          return module.exports;
        } catch (err) {
          delete cache[path];
          throw err;
        }
      } else {
        throw 'module \'' + name + '\' not found';
      }
    }, expand = function(root, name) {
      var results = [], parts, part;
      if (/^\.\.?(\/|$)/.test(name)) {
        parts = [root, name].join('/').split('/');
      } else {
        parts = name.split('/');
      }
      for (var i = 0, length = parts.length; i < length; i++) {
        part = parts[i];
        if (part == '..') {
          results.pop();
        } else if (part != '.' && part != '') {
          results.push(part);
        }
      }
      return results.join('/');
    }, dirname = function(path) {
      return path.split('/').slice(0, -1).join('/');
    };
    this.require = function(name) {
      return require(name, '');
    }
    this.require.define = function(bundle) {
      for (var key in bundle)
        modules[key] = bundle[key];
    };
  }
  return this.require.define;
}).call(this)({"fits.binarytable": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var BinaryTable, Tabular,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Tabular = require('./fits.tabular');

  BinaryTable = (function(_super) {

    __extends(BinaryTable, _super);

    BinaryTable.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    BinaryTable.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    function BinaryTable(view, header) {
      var dataType, i, keyword, length, match, value, _i, _ref, _ref1,
        _this = this;
      BinaryTable.__super__.constructor.apply(this, arguments);
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        keyword = "TFORM" + i;
        value = header[keyword];
        match = value.match(BinaryTable.arrayDescriptorPattern);
        if (match != null) {
          (function() {
            var accessor, dataType;
            dataType = match[1];
            accessor = function() {
              var data, length, offset, _j;
              length = _this.view.getInt32();
              offset = _this.view.getInt32();
              _this.current = _this.view.tell();
              _this.view.seek(_this.begin + _this.tableLength + offset);
              data = [];
              for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                data.push(BinaryTable.dataAccessors[dataType](_this.view));
              }
              _this.view.seek(_this.current);
              return data;
            };
            return _this.accessors.push(accessor);
          })();
        } else {
          match = value.match(BinaryTable.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              var accessor;
              accessor = function() {
                var data;
                data = BinaryTable.dataAccessors[dataType](_this.view);
                return data;
              };
              return _this.accessors.push(accessor);
            })(dataType);
          } else {
            (function(dataType) {
              var accessor;
              accessor = function() {
                var data, _j;
                data = [];
                for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                  data.push(BinaryTable.dataAccessors[dataType](_this.view));
                }
                return data;
              };
              return _this.accessors.push(accessor);
            })(dataType);
          }
        }
      }
    }

    return BinaryTable;

  })(Tabular);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = BinaryTable;
  }

}).call(this);
}, "fits.compressedimage": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var CompImage, Decompress, Tabular,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Tabular = require('./fits.tabular');

  Decompress = require('./fits.decompress');

  CompImage = (function(_super) {

    __extends(CompImage, _super);

    CompImage.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    CompImage.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    CompImage.extend(Decompress);

    CompImage.typedArray = {
      B: Uint8Array,
      I: Int16Array,
      J: Int32Array,
      E: Float32Array,
      D: Float64Array,
      1: Uint8Array,
      2: Uint8Array,
      4: Int16Array,
      8: Int32Array
    };

    function CompImage(view, header) {
      var i, key, value, ztile, _i, _ref;
      CompImage.__super__.constructor.apply(this, arguments);
      this.length += header["PCOUNT"];
      this.zcmptype = header["ZCMPTYPE"];
      this.zbitpix = header["ZBITPIX"];
      this.znaxis = header["ZNAXIS"];
      this.zblank = CompImage.setValue(header, "ZBLANK", void 0);
      this.blank = CompImage.setValue(header, "BLANK", void 0);
      this.min = header["DATAMIN"] != null ? header["DATAMIN"] : void 0;
      this.max = header["DATAMAX"] != null ? header["DATAMAX"] : void 0;
      this.ztile = [];
      for (i = _i = 1, _ref = this.znaxis; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        ztile = header.contains("ZTILE" + i) ? header["ZTILE" + i] : i === 1 ? header["ZNAXIS1"] : 1;
        this.ztile.push(ztile);
      }
      this.algorithmParameters = {};
      i = 1;
      while (true) {
        key = "ZNAME" + i;
        if (!header.contains(key)) {
          break;
        }
        value = "ZVAL" + i;
        this.algorithmParameters[header[key]] = header[value];
        i += 1;
      }
      this["setDefaultParameters_" + this.zcmptype]();
      this.zmaskcmp = CompImage.setValue(header, "ZMASKCMP", void 0);
      this.zquantiz = CompImage.setValue(header, "ZQUANTIZ", "LINEAR_SCALING");
      this.bzero = CompImage.setValue(header, "BZERO", 0);
      this.bscale = CompImage.setValue(header, "BSCALE", 1);
      this.defineColumnAccessors(header);
      this.defineGetRow();
    }

    CompImage.prototype.defineColumnAccessors = function(header) {
      var accessor, dataType, i, length, match, ttype, value, _i, _ref, _ref1, _results,
        _this = this;
      this.columnNames = {};
      _results = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        value = header["TFORM" + i];
        match = value.match(CompImage.arrayDescriptorPattern);
        ttype = header["TTYPE" + i].toUpperCase();
        this.columnNames[ttype] = i - 1;
        accessor = null;
        if (match != null) {
          dataType = match[1];
          switch (ttype) {
            case "COMPRESSED_DATA":
              (function(dataType) {
                return accessor = function() {
                  var data, pixels;
                  data = _this._accessor(dataType);
                  if (data == null) {
                    return null;
                  }
                  pixels = new CompImage.typedArray[_this.algorithmParameters["BYTEPIX"]](_this.ztile[0]);
                  CompImage.Rice(data, length, _this.algorithmParameters["BLOCKSIZE"], _this.algorithmParameters["BYTEPIX"], pixels, _this.ztile[0]);
                  return pixels;
                };
              })(dataType);
              break;
            case "UNCOMPRESSED_DATA":
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
              break;
            case "GZIP_COMPRESSED_DATA":
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
              break;
            default:
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
          }
        } else {
          match = value.match(CompImage.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length != null ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              return accessor = function() {
                return CompImage.dataAccessors[dataType](_this.view);
              };
            })(dataType);
          } else {
            (function(length, dataType) {
              return accessor = function() {
                var data, _j, _ref2;
                data = new CompImage.typedArray[dataType](length);
                for (i = _j = 0, _ref2 = length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                  data[i] = CompImage.dataAccessors[dataType](_this.view);
                }
                return data;
              };
            })(length, dataType);
          }
        }
        _results.push(this.accessors.push(accessor));
      }
      return _results;
    };

    CompImage.prototype.defineGetRow = function() {
      var hasBlanks;
      hasBlanks = (this.zblank != null) || (this.blank != null) || this.columnNames.hasOwnProperty("ZBLANK");
      return this.getRow = hasBlanks ? this.getRowHasBlanks : this.getRowNoBlanks;
    };

    CompImage.prototype.setDefaultParameters_RICE_1 = function() {
      if (!this.algorithmParameters.hasOwnProperty("BLOCKSIZE")) {
        this.algorithmParameters["BLOCKSIZE"] = 32;
      }
      if (!this.algorithmParameters.hasOwnProperty("BYTEPIX")) {
        return this.algorithmParameters["BYTEPIX"] = 4;
      }
    };

    CompImage.setValue = function(header, key, defaultValue) {
      if (header.contains(key)) {
        return header[key];
      } else {
        return defaultValue;
      }
    };

    CompImage.prototype.getFrame = function() {
      var index, location, row, value, _i, _len;
      this.rowsRead = 0;
      this.data = new Float32Array(this.ztile[0] * this.rows);
      while (true) {
        row = this.getRow();
        for (index = _i = 0, _len = row.length; _i < _len; index = ++_i) {
          value = row[index];
          location = this.rowsRead * this.ztile[0] + index;
          this.data[this.rowsRead * this.ztile[0] + index] = value;
        }
        if (this.rowsRead === this.rows) {
          break;
        }
      }
      return this.data;
    };

    CompImage.prototype.getRowHasBlanks = function() {
      var blank, data, index, pixels, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      pixels = new Float32Array(data.length);
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        if (value === blank) {
          pixels[index] = NaN;
          continue;
        }
        pixels[index] = zero + (scale * value);
      }
      return pixels;
    };

    CompImage.prototype.getRowNoBlanks = function() {
      var blank, data, index, pixels, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      pixels = new Float32Array(data.length);
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        pixels[index] = zero + scale * value;
      }
      return pixels;
    };

    CompImage.prototype._accessor = function(dataType) {
      var data, i, length, offset, _i, _ref, _ref1;
      _ref = [this.view.getInt32(), this.view.getInt32()], length = _ref[0], offset = _ref[1];
      if (length === 0) {
        return null;
      }
      data = new CompImage.typedArray[dataType](length);
      this.current = this.view.tell();
      this.view.seek(this.begin + this.tableLength + offset);
      for (i = _i = 0, _ref1 = length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        data[i] = CompImage.dataAccessors[dataType](this.view);
      }
      this.view.seek(this.current);
      return data;
    };

    CompImage.prototype._getRow = function() {
      var accessor, blank, data, row, scale, zero, _i, _len, _ref;
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = [];
      _ref = this.accessors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        accessor = _ref[_i];
        row.push(accessor());
      }
      this.rowsRead += 1;
      data = row[this.columnNames["COMPRESSED_DATA"]] || row[this.columnNames["UNCOMPRESSED_DATA"]] || row[this.columnNames["GZIP_COMPRESSED_DATA"]];
      blank = row[this.columnNames["ZBLANK"]] || this.zblank;
      scale = row[this.columnNames["ZSCALE"]] || this.bscale;
      zero = row[this.columnNames["ZZERO"]] || this.bzero;
      return [data, blank, scale, zero];
    };

    CompImage.prototype.getExtremes = function() {
      var i, index, max, min, value, _i, _j, _len, _ref, _ref1, _ref2, _ref3;
      if ((this.min != null) && (this.max != null)) {
        return [this.min, this.max];
      }
      _ref = this.data;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        value = _ref[index];
        if (isNaN(value)) {
          continue;
        }
        _ref1 = [value, value], min = _ref1[0], max = _ref1[1];
        break;
      }
      for (i = _j = index, _ref2 = this.data.length - 1; index <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = index <= _ref2 ? ++_j : --_j) {
        value = this.data[i];
        if (isNaN(value)) {
          continue;
        }
        if (value < min) {
          min = value;
        }
        if (value > max) {
          max = value;
        }
      }
      _ref3 = [min, max], this.min = _ref3[0], this.max = _ref3[1];
      return [this.min, this.max];
    };

    CompImage.subtractiveDither1 = function() {
      throw "Not yet implemented";
    };

    CompImage.linearScaling = function() {
      throw "Not yet implemented";
    };

    return CompImage;

  })(Tabular);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = CompImage;
  }

}).call(this);
}, "fits.data": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var Data, Module,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Module = require('./fits.module');

  Data = (function(_super) {

    __extends(Data, _super);

    function Data(view, header) {
      this.view = view;
      this.begin = this.current = view.tell();
      this.length = void 0;
    }

    return Data;

  })(Module);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Data;
  }

}).call(this);
}, "fits.decompress": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var Decompress;

  Decompress = {
    Rice: function(array, arrayLen, blocksize, bytepix, pixels, nx) {
      var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer, _ref, _ref1;
      bbits = 1 << fsbits;
      _ref = this.RiceSetup[bytepix](array), fsbits = _ref[0], fsmax = _ref[1], lastpix = _ref[2], pointer = _ref[3];
      nonzeroCount = new Uint8Array(256);
      nzero = 8;
      _ref1 = [128, 255], k = _ref1[0], i = _ref1[1];
      while (i >= 0) {
        while (i >= k) {
          nonzeroCount[i] = nzero;
          i -= 1;
        }
        k = k / 2;
        nzero -= 1;
      }
      nonzeroCount[0] = 0;
      b = array[pointer];
      pointer += 1;
      nbits = 8;
      i = 0;
      while (i < nx) {
        nbits -= fsbits;
        while (nbits < 0) {
          b = (b << 8) | array[pointer];
          pointer += 1;
          nbits += 8;
        }
        fs = (b >> nbits) - 1;
        b &= (1 << nbits) - 1;
        imax = i + blocksize;
        if (imax > nx) {
          imax = nx;
        }
        if (fs < 0) {
          while (i < imax) {
            array[i] = lastpix;
            i++;
          }
        } else if (fs === fsmax) {
          while (i < imax) {
            k = bbits - nbits;
            diff = b << k;
            k -= 8;
            while (k >= 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b << k;
              k -= 8;
            }
            if (nbits > 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b >> (-k);
              b &= (1 << nbits) - 1;
            } else {
              b = 0;
            }
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            array[i] = diff + lastpix;
            lastpix = array[i];
            i++;
          }
        } else {
          while (i < imax) {
            while (b === 0) {
              nbits += 8;
              b = array[pointer];
              pointer += 1;
            }
            nzero = nbits - nonzeroCount[b];
            nbits -= nzero + 1;
            b ^= 1 << nbits;
            nbits -= fs;
            while (nbits < 0) {
              b = (b << 8) | array[pointer];
              pointer += 1;
              nbits += 8;
            }
            diff = (nzero << fs) | (b >> nbits);
            b &= (1 << nbits) - 1;
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            pixels[i] = diff + lastpix;
            lastpix = pixels[i];
            i++;
          }
        }
      }
      return pixels;
    },
    RiceSetup: {
      1: function(array) {
        var fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 3;
        fsmax = 6;
        lastpix = array[pointer];
        pointer += 1;
        return [fsbits, fsmax, lastpix, pointer];
      },
      2: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 4;
        fsmax = 14;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      },
      4: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 5;
        fsmax = 25;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 24);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 16);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      }
    },
    gzip: function(array) {
      throw "Not yet implemented";
    },
    plio: function(array, length) {
      throw "Not yet implemented";
    },
    hcompress: function(array, length) {
      throw "Not yet implemented";
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Decompress;
  }

}).call(this);
}, "fits.file": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var BinaryTable, CompImage, File, HDU, Header, Image, Table;

  HDU = require('./fits.hdu');

  Header = require('./fits.header');

  Image = require('./fits.image');

  CompImage = require('./fits.compressedimage');

  Table = require('./fits.table');

  BinaryTable = require('./fits.binarytable');

  File = (function() {

    File.LINEWIDTH = 80;

    File.BLOCKLENGTH = 2880;

    function File(buffer) {
      var data, hdu, header;
      this.length = buffer.byteLength;
      this.view = new jDataView(buffer, void 0, void 0, false);
      this.hdus = [];
      this.eof = false;
      while (true) {
        header = this.readHeader();
        data = this.readData(header);
        hdu = new HDU(header, data);
        this.hdus.push(hdu);
        if (this.eof) {
          break;
        }
      }
    }

    File.excessBytes = function(length) {
      return (File.BLOCKLENGTH - (length % File.BLOCKLENGTH)) % File.BLOCKLENGTH;
    };

    File.prototype.readHeader = function() {
      var excess, header, line, linesRead;
      linesRead = 0;
      header = new Header();
      while (true) {
        line = this.view.getString(File.LINEWIDTH);
        linesRead += 1;
        header.readCard(line);
        if (line.slice(0, 4) === "END ") {
          break;
        }
      }
      excess = File.excessBytes(linesRead * File.LINEWIDTH);
      this.view.seek(this.view.tell() + excess);
      this.checkEOF();
      return header;
    };

    File.prototype.readData = function(header) {
      var data, excess;
      if (!header.hasDataUnit()) {
        return;
      }
      if (header.isPrimary()) {
        data = new Image(this.view, header);
      } else if (header.isExtension()) {
        if (header.extensionType === "BINTABLE") {
          if (header.contains("ZIMAGE")) {
            data = new CompImage(this.view, header);
          } else {
            data = new BinaryTable(this.view, header);
          }
        } else if (header.extensionType === "TABLE") {
          data = new Table(this.view, header);
        }
      }
      excess = File.excessBytes(data.length);
      this.view.seek(this.view.tell() + data.length + excess);
      this.checkEOF();
      return data;
    };

    File.prototype.checkEOF = function() {
      if (this.view.tell() === this.length) {
        return this.eof = true;
      }
    };

    File.prototype.count = function() {
      return this.hdus.length;
    };

    File.prototype.getHDU = function(index) {
      var hdu, _i, _len, _ref;
      if (index == null) {
        index = void 0;
      }
      if ((index != null) && (this.hdus[index] != null)) {
        return this.hdus[index];
      }
      _ref = this.hdus;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hdu = _ref[_i];
        if (hdu.hasData()) {
          return hdu;
        }
      }
    };

    File.prototype.getHeader = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).header;
    };

    File.prototype.getDataUnit = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).data;
    };

    File.prototype.getData = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).data.getFrame();
    };

    return File;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = File;
  }

}).call(this);
}, "fits.hdu": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var HDU;

  HDU = (function() {

    function HDU(header, data) {
      this.header = header;
      this.data = data;
    }

    HDU.prototype.hasData = function() {
      if (this.data != null) {
        return true;
      } else {
        return false;
      }
    };

    HDU.prototype.getCard = function(key) {
      return this.header[key];
    };

    return HDU;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = HDU;
  }

}).call(this);
}, "fits.header": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var Header, Module, VerifyCards,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Module = require('./fits.module');

  VerifyCards = require('./fits.header.verify');

  Header = (function(_super) {

    __extends(Header, _super);

    Header.keywordPattern = /([\w_-]+)\s*=?\s*(.*)/;

    Header.nonStringPattern = /([^\/]*)\s*\/*(.*)/;

    Header.stringPattern = /'(.*)'\s*\/*(.*)/;

    Header.arrayPattern = /([A-Za-z]+)(\d+)/;

    Header.include(VerifyCards);

    function Header() {
      var method, name, _ref;
      this.verifyCard = {};
      _ref = this.Functions;
      for (name in _ref) {
        method = _ref[name];
        this.verifyCard[name] = this.proxy(method);
      }
      this.cards = {};
      this.cardIndex = 0;
    }

    Header.prototype.get = function(key) {
      if (this.contains(key)) {
        return this.cards[key];
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getIndex = function(key) {
      if (this.contains(key)) {
        return this.cards[key][0];
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getComment = function(key) {
      if (this.contains(key)) {
        if (this.cards[key][2] != null) {
          return this.cards[key][2];
        } else {
          return console.warn("" + key + " does not contain a comment");
        }
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getComments = function() {
      if (this.contains('COMMENT')) {
        return this.cards['COMMENT'];
      } else {
        return console.warn("Header does not contain any COMMENT fields");
      }
    };

    Header.prototype.getHistory = function() {
      if (this.contains('HISTORY')) {
        return this.cards['HISTORY'];
      } else {
        return console.warn("Header does not contain any HISTORY fields");
      }
    };

    Header.prototype.set = function(key, value, comment) {
      this.cards[key] = comment ? [this.cardIndex, value, comment] : [this.cardIndex, value];
      return this.cardIndex += 1;
    };

    Header.prototype.setComment = function(comment) {
      if (!this.contains("COMMENT")) {
        this.cards["COMMENT"] = [];
        this.cardIndex += 1;
      }
      return this.cards["COMMENT"].push(comment);
    };

    Header.prototype.setHistory = function(history) {
      if (!this.contains("HISTORY")) {
        this.cards["HISTORY"] = [];
        this.cardIndex += 1;
      }
      return this.cards["HISTORY"].push(history);
    };

    Header.prototype.contains = function(keyword) {
      return this.cards.hasOwnProperty(keyword);
    };

    Header.prototype.readCard = function(line) {
      var array, comment, index, key, keyToVerify, match, value, _ref, _ref1, _ref2, _ref3, _ref4;
      match = line.match(Header.keywordPattern);
      if (match == null) {
        return;
      }
      _ref = match.slice(1), key = _ref[0], value = _ref[1];
      if (key === "COMMENT" || key === "HISTORY") {
        match[1] = value.trim();
      } else if (value[0] === "'") {
        match = value.match(Header.stringPattern);
        match[1] = match[1].trim();
      } else {
        match = value.match(Header.nonStringPattern);
        match[1] = (_ref1 = match[1][0]) === "T" || _ref1 === "F" ? match[1].trim() : parseFloat(match[1]);
      }
      match[2] = match[2].trim();
      _ref2 = match.slice(1), value = _ref2[0], comment = _ref2[1];
      keyToVerify = key;
      _ref3 = [false, void 0], array = _ref3[0], index = _ref3[1];
      match = key.match(Header.arrayPattern);
      if (match != null) {
        keyToVerify = match[1];
        _ref4 = [true, match[2]], array = _ref4[0], index = _ref4[1];
      }
      if (this.verifyCard.hasOwnProperty(keyToVerify)) {
        value = this.verifyCard[keyToVerify](value, array, index);
      }
      switch (key) {
        case "COMMENT":
          return this.setComment(value);
        case "HISTORY":
          return this.setHistory(value);
        default:
          this.set(key, value, comment);
          return this.__defineGetter__(key, function() {
            return this.cards[key][1];
          });
      }
    };

    Header.prototype.hasDataUnit = function() {
      if (this["NAXIS"] === 0) {
        return false;
      } else {
        return true;
      }
    };

    return Header;

  })(Module);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Header;
  }

}).call(this);
}, "fits.header.verify": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var VerifyCards,
    __slice = [].slice;

  VerifyCards = {
    primary: false,
    extension: false,
    isPrimary: function() {
      return this.primary;
    },
    isExtension: function() {
      return this.extension;
    },
    verifyOrder: function(keyword, order) {
      if (order !== this.cardIndex) {
        return console.warn("" + keyword + " should appear at index " + order + " in the FITS header");
      }
    },
    verifyBetween: function(keyword, value, lower, upper) {
      if (!(value >= lower && value <= upper)) {
        throw "The " + keyword + " value of " + value + " is not between " + lower + " and " + upper;
      }
    },
    verifyInteger: function(keyword, value) {
      var val;
      val = parseInt(value);
      if (val !== value) {
        throw "The " + keyword + " value of " + value + " is not an integer";
      }
      return val;
    },
    Functions: {
      SIMPLE: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.primary = true;
        this.verifyOrder("SIMPLE", 0);
        if (value === "T") {
          return true;
        } else {
          return false;
        }
      },
      XTENSION: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.extension = true;
        this.extensionType = value;
        this.verifyOrder("XTENSION", 0);
        return value;
      },
      BITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BITPIX";
        value = this.verifyInteger(key, arguments[0]);
        this.verifyOrder(key, 1);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return parseInt(value);
      },
      NAXIS: function() {
        var args, array, key, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "NAXIS";
        value = arguments[0];
        array = arguments[1];
        value = this.verifyInteger(key, value);
        if (!array) {
          this.verifyOrder(key, 2);
          this.verifyBetween(key, value, 0, 999);
          if (this.isExtension()) {
            if ((_ref = this.extensionType) === "TABLE" || _ref === "BINTABLE") {
              required = 2;
              if (value !== required) {
                throw "" + key + " must be " + required + " for TABLE and BINTABLE extensions";
              }
            }
          }
        }
        return value;
      },
      PCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "PCOUNT";
        value = this.verifyInteger(key, arguments[0]);
        order = 1 + 1 + 1 + this["NAXIS"];
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE") {
            required = 0;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      GCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "GCOUNT";
        value = this.verifyInteger(key, arguments[0]);
        order = 1 + 1 + 1 + this["NAXIS"] + 1;
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE" || _ref === "BINTABLE") {
            required = 1;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      EXTEND: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTEND";
        value = arguments[0];
        if (!this.isPrimary()) {
          throw "" + key + " must only appear in the primary header";
        }
        if (value === "T") {
          return true;
        } else {
          return false;
        }
      },
      BSCALE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BZERO: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BLANK: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BLANK";
        value = arguments[0];
        if (!(this["BIXPIX"] > 0)) {
          throw "" + key + " is not to be used for BITPIX = " + this['BITPIX'];
        }
        return this.verifyInteger(value);
      },
      DATAMIN: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      DATAMAX: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      EXTVER: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key("EXTVER");
        value = arguments[0];
        value = this.verifyInteger(key, value);
        return value;
      },
      EXTLEVEL: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTLEVEL";
        value = arguments[0];
        value = this.verifyInteger(key, value);
        return value;
      },
      TFIELDS: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "TFIELDS";
        value = arguments[0];
        value = this.verifyInteger(key, value);
        this.verifyBetween(key, value, 0, 999);
        return value;
      },
      TBCOL: function() {
        var args, index, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "TBCOL";
        value = arguments[0];
        index = arguments[2];
        this.verifyBetween(key, index, 0, this["TFIELDS"]);
        return value;
      },
      ZIMAGE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZIMAGE";
        value = arguments[0];
        if (value === "T") {
          return true;
        } else {
          return false;
        }
      },
      ZCMPTYPE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZCMPTYPE";
        value = arguments[0];
        if (value !== "GZIP_1" && value !== "RICE_1" && value !== "PLIO_1" && value !== "HCOMPRESS_1") {
          throw "" + key + " value " + value + " is not permitted";
        }
        if (value !== "RICE_1") {
          throw "Compress type " + value + " is not yet implement";
        }
        return value;
      },
      ZBITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZBITPIX";
        value = this.verifyInteger(key, arguments[0]);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return parseInt(value);
      },
      ZNAXIS: function() {
        var args, array, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZNAXIS";
        value = arguments[0];
        array = arguments[1];
        value = this.verifyInteger(key, value);
        if (!array) {
          this.verifyBetween(key, value, 0, 999);
        }
        return value;
      },
      ZTILE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZTILE";
        value = this.verifyInteger(key, arguments[0]);
        return value;
      },
      ZSIMPLE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (arguments[0] === "T") {
          return true;
        } else {
          return false;
        }
      },
      ZPCOUNT: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZPCOUNT";
        value = arguments[0];
        return this.verifyInteger(key, value);
      },
      ZGCOUNT: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZGCOUNT";
        value = arguments[0];
        return this.verifyInteger(key, value);
      }
    }
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = VerifyCards;
  }

}).call(this);
}, "fits.image": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var Data, Image,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Data = require('./fits.data');

  Image = (function(_super) {

    __extends(Image, _super);

    function Image(view, header) {
      var bitpix, i, naxis, _i,
        _this = this;
      Image.__super__.constructor.apply(this, arguments);
      naxis = header["NAXIS"];
      bitpix = header["BITPIX"];
      this.naxis = [];
      for (i = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; i = 1 <= naxis ? ++_i : --_i) {
        this.naxis.push(header["NAXIS" + i]);
      }
      this.rowByteSize = header["NAXIS1"] * Math.abs(bitpix) / 8;
      this.rowsRead = 0;
      this.min = header["DATAMIN"] != null ? header["DATAMIN"] : void 0;
      this.max = header["DATAMAX"] != null ? header["DATAMAX"] : void 0;
      this.length = this.naxis.reduce(function(a, b) {
        return a * b;
      }) * Math.abs(bitpix) / 8;
      this.data = void 0;
      this.frame = -1;
      switch (bitpix) {
        case 8:
          this.arrayType = Uint8Array;
          this.accessor = function() {
            return _this.view.getUint8();
          };
          break;
        case 16:
          this.arrayType = Int16Array;
          this.accessor = function() {
            return _this.view.getInt16();
          };
          break;
        case 32:
          this.arrayType = Int32Array;
          this.accessor = function() {
            return _this.view.getInt32();
          };
          break;
        case 64:
          this.arrayType = Int32Array;
          this.accessor = function() {
            var factor, highByte, lowByte, mod, value;
            console.warn("Something funky happens here when dealing with 64 bit integers.  Be wary!!!");
            highByte = Math.abs(_this.view.getInt32());
            lowByte = Math.abs(_this.view.getInt32());
            mod = highByte % 10;
            factor = mod ? -1 : 1;
            highByte -= mod;
            value = factor * ((highByte << 32) | lowByte);
            return value;
          };
          break;
        case -32:
          this.arrayType = Float32Array;
          this.accessor = function() {
            return _this.view.getFloat32();
          };
          break;
        case -64:
          this.arrayType = Float64Array;
          this.accessor = function() {
            return _this.view.getFloat64();
          };
          break;
        default:
          throw "FITS keyword BITPIX does not conform to one of the following set values [8, 16, 32, 64, -32, -64]";
      }
    }

    Image.prototype.initArray = function() {
      return this.data = new this.arrayType(this.naxis.reduce(function(a, b) {
        return a * b;
      }));
    };

    Image.prototype.getRow = function() {
      var i, rowLength, _i, _ref;
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      rowLength = this.naxis[0];
      this.view.seek(this.current);
      for (i = _i = 0, _ref = rowLength - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.data[rowLength * this.rowsRead + i] = this.accessor();
      }
      return this.rowsRead += 1;
    };

    Image.prototype.getFrame = function() {
      var i, _i, _ref;
      if (this.data == null) {
        this.initArray();
      }
      for (i = _i = 0, _ref = this.naxis[1] - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.getRow();
      }
      this.frame += 1;
      return this.data;
    };

    Image.prototype.getFrameWebGL = function() {
      var i, j, rowLength, _i, _j, _ref, _ref1;
      this.data = new Float32Array(this.naxis.reduce(function(a, b) {
        return a * b;
      }));
      this.rowsRead = 0;
      rowLength = this.naxis[0];
      for (j = _i = 0, _ref = this.naxis[1] - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; j = 0 <= _ref ? ++_i : --_i) {
        this.current = this.begin + this.rowsRead * this.rowByteSize;
        this.view.seek(this.current);
        for (i = _j = 0, _ref1 = rowLength - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          this.data[rowLength * this.rowsRead + i] = this.accessor();
        }
        this.rowsRead += 1;
      }
      this.frame += 1;
      return this.data;
    };

    Image.prototype.getExtremes = function() {
      var i, index, max, min, value, _i, _j, _len, _ref, _ref1, _ref2, _ref3;
      if ((this.min != null) && (this.max != null)) {
        return [this.min, this.max];
      }
      _ref = this.data;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        value = _ref[index];
        if (isNaN(value)) {
          continue;
        }
        _ref1 = [value, value], min = _ref1[0], max = _ref1[1];
        break;
      }
      for (i = _j = index, _ref2 = this.data.length - 1; index <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = index <= _ref2 ? ++_j : --_j) {
        value = this.data[i];
        if (isNaN(value)) {
          continue;
        }
        if (value < min) {
          min = value;
        }
        if (value > max) {
          max = value;
        }
      }
      _ref3 = [min, max], this.min = _ref3[0], this.max = _ref3[1];
      return [this.min, this.max];
    };

    Image.prototype.getPixel = function(x, y) {
      return this.data[(this.frame * this.naxis[0] * this.naxis[1]) + y * this.naxis[0] + x];
    };

    Image.prototype.seek = function(frame) {
      if (frame == null) {
        frame = 0;
      }
      if (this.naxis.length === 2) {
        this.rowsRead = 0;
        return this.frame = -1;
      } else {
        this.rowsRead = this.naxis[1] * (frame + 1);
        return this.frame = this.naxis[1] / this.rowsRead - 1;
      }
    };

    return Image;

  })(Data);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Image;
  }

}).call(this);
}, "fits.imageset": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var ImageSet;

  ImageSet = (function() {

    function ImageSet() {
      this.images = {};
      this.keys = [];
      this.minimum = void 0;
      this.maximum = void 0;
      this.count = 0;
    }

    ImageSet.prototype.getExtremes = function() {
      var data, extremes, image, key, maximums, minimums, _ref;
      minimums = [];
      maximums = [];
      _ref = this.images;
      for (key in _ref) {
        image = _ref[key];
        data = image.getHDU().data;
        data.getFrame();
        extremes = data.getExtremes();
        minimums.push(extremes[0]);
        maximums.push(extremes[1]);
      }
      this.minimum = Math.min.apply(Math, minimums);
      return this.maximum = Math.max.apply(Math, maximums);
    };

    ImageSet.prototype.addImage = function(image) {
      var filter, index;
      filter = image.getHDU().header["FILTER"] || this.count;
      this.keys.push(filter);
      this.images[filter] = image;
      index = this.count;
      this.__defineGetter__(index, function() {
        return this.images[this.keys[index]];
      });
      return this.count += 1;
    };

    ImageSet.prototype.getWidth = function() {
      var key;
      key = this.keys[0];
      if (this.images[key] == null) {
        return null;
      }
      return this.images[key].getHDU().header["NAXIS1"];
    };

    ImageSet.prototype.getHeight = function() {
      var key;
      key = this.keys[0];
      if (this.images[key] == null) {
        return null;
      }
      return this.images[key].getHDU().header["NAXIS2"];
    };

    ImageSet.prototype.getCount = function() {
      return this.count;
    };

    ImageSet.prototype.getData = function(filter) {
      return this[filter].getHDU().data.data;
    };

    ImageSet.prototype.seek = function(frame) {
      var image, key, _ref, _results;
      if (frame == null) {
        frame = 0;
      }
      _ref = this.images;
      _results = [];
      for (key in _ref) {
        image = _ref[key];
        _results.push(image.getDataUnit().seek(frame));
      }
      return _results;
    };

    return ImageSet;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ImageSet;
  }

}).call(this);
}, "fits.imagestats": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var CompImage, Header, Image, ImageStats;

  Header = require('./fits.header');

  Image = require('./fits.image');

  CompImage = require('./fits.compressedimage');

  ImageStats = (function() {

    function ImageStats(image) {
      var _ref;
      this.image = image;
      _ref = this.image.getExtremes(), this.minimum = _ref[0], this.maximum = _ref[1];
      this.pixels = this.image.naxis.reduce(function(a, b) {
        return a * b;
      });
      this.mean = void 0;
      this.std = void 0;
      this.histogram = void 0;
      this.bins = void 0;
    }

    ImageStats.prototype.computeMean = function() {
      var pixel, sum, _i, _len, _ref;
      if (this.mean != null) {
        return this.mean;
      }
      sum = 0;
      _ref = this.image.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pixel = _ref[_i];
        sum += pixel;
      }
      return this.mean = sum / this.pixels;
    };

    ImageStats.prototype.computeSTD = function() {
      var diff, pixel, sum, _i, _len, _ref;
      if (this.std != null) {
        return this.std;
      }
      if (this.mean == null) {
        this.computeMean();
      }
      sum = 0;
      _ref = this.image.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pixel = _ref[_i];
        diff = pixel - this.mean;
        sum += diff * diff;
      }
      return this.std = Math.sqrt(sum / this.pixels);
    };

    ImageStats.prototype.computeHistogram = function(bins) {
      var arrayType, binSize, data, index, pixel, range, _i, _len;
      this.bins = bins != null ? bins : 100;
      range = this.maximum - this.minimum;
      binSize = range / this.bins;
      data = this.image.data;
      if (this.pixels < 256) {
        arrayType = Uint8Array;
      } else if (this.pixels < 65535) {
        arrayType = Uint16Array;
      } else {
        arrayType = Uint32Array;
      }
      this.histogram = new arrayType(this.bins + 1);
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        pixel = data[_i];
        index = Math.floor(((pixel - this.minimum) / range) * this.bins);
        this.histogram[index] += 1;
      }
      return this.histogram;
    };

    return ImageStats;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ImageStats;
  }

}).call(this);
}, "fits": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var FITS;

  FITS = this.FITS = {};

  FITS.VERSION = '0.0.2';

  FITS.HDU = require('./fits.hdu');

  FITS.File = require('./fits.file');

  FITS.Header = require('./fits.header');

  FITS.Image = require('./fits.image');

  FITS.BinTable = require('./fits.binarytable');

  FITS.CompImage = require('./fits.compressedimage');

  FITS.Table = require('./fits.table');

  FITS.ImageSet = require('./fits.imageset');

  FITS.Visualize = require('./fits.visualize');

  FITS.ImageStats = require('./fits.imagestats');

  if (typeof module !== "undefined" && module !== null) {
    module.exports = FITS;
  }

}).call(this);
}, "fits.module": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var Module, moduleKeywords,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  moduleKeywords = ['included', 'extended'];

  Module = (function() {

    function Module() {}

    Module.include = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'include(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((_ref = obj.included) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.extend = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'extend(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((_ref = obj.extended) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    Module.prototype.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    return Module;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Module;
  }

}).call(this);
}, "fits.table": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var Table, Tabular,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Tabular = require('./fits.tabular');

  Table = (function(_super) {

    __extends(Table, _super);

    Table.formPattern = /([AIFED])(\d+)\.(\d+)/;

    Table.dataAccessors = {
      A: function(value) {
        return value;
      },
      I: function(value) {
        return parseInt(value);
      },
      F: function(value) {
        return parseFloat(value);
      },
      E: function(value) {
        return parseFloat(value);
      },
      D: function(value) {
        return parseFloat(value);
      }
    };

    function Table(view, header) {
      var form, i, match, _fn, _i, _ref,
        _this = this;
      Table.__super__.constructor.apply(this, arguments);
      _fn = function() {
        var accessor, dataType, decimals, length, _ref1;
        _ref1 = match.slice(1), dataType = _ref1[0], length = _ref1[1], decimals = _ref1[2];
        accessor = function() {
          var value, _j;
          value = "";
          for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
            value += _this.view.getChar();
          }
          return FITS.Table.dataAccessors[dataType](value);
        };
        return _this.accessors.push(accessor);
      };
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        form = header["TFORM" + i];
        match = form.match(Table.formPattern);
        _fn();
      }
    }

    return Table;

  })(Tabular);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Table;
  }

}).call(this);
}, "fits.tabular": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var Data, Tabular,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Data = require('./fits.data');

  Tabular = (function(_super) {

    __extends(Tabular, _super);

    Tabular.dataAccessors = {
      L: function(view) {
        var value;
        value = view.getInt8() === 84 ? true : false;
        return value;
      },
      X: function(view) {
        throw "Data type not yet implemented";
      },
      B: function(view) {
        return view.getUint8();
      },
      I: function(view) {
        return view.getInt16();
      },
      J: function(view) {
        return view.getInt32();
      },
      K: function(view) {
        var factor, highByte, lowByte, mod, value;
        highByte = Math.abs(view.getInt32());
        lowByte = Math.abs(view.getInt32());
        mod = highByte % 10;
        factor = mod ? -1 : 1;
        highByte -= mod;
        value = factor * ((highByte << 32) | lowByte);
        console.warn("Something funky happens here when dealing with 64 bit integers.  Be wary!!!");
        return value;
      },
      A: function(view) {
        return view.getChar();
      },
      E: function(view) {
        return view.getFloat32();
      },
      D: function(view) {
        return view.getFloat64();
      },
      C: function(view) {
        return [view.getFloat32(), view.getFloat32()];
      },
      M: function(view) {
        return [view.getFloat64(), view.getFloat64()];
      }
    };

    function Tabular(view, header) {
      Tabular.__super__.constructor.apply(this, arguments);
      this.rowByteSize = header["NAXIS1"];
      this.rows = header["NAXIS2"];
      this.cols = header["TFIELDS"];
      this.length = this.tableLength = this.rowByteSize * this.rows;
      this.rowsRead = 0;
      this.accessors = [];
    }

    Tabular.prototype.getRow = function() {
      var accessor, row, _i, _len, _ref;
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = [];
      _ref = this.accessors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        accessor = _ref[_i];
        row.push(accessor());
      }
      this.rowsRead += 1;
      return row;
    };

    return Tabular;

  })(Data);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Tabular;
  }

}).call(this);
}, "fits.visualize": function(exports, require, module) {// Generated by CoffeeScript 1.3.3
(function() {
  var Visualize;

  Visualize = (function() {

    Visualize.GET_A_WEBGL_BROWSER = '' + 'This page requires a browser that supports WebGL.<br/>' + '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';

    Visualize.OTHER_PROBLEM = '' + "It doesn't appear your computer can support WebGL.<br/>" + '<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>';

    Visualize.vertexShader = ["attribute vec2 a_position;", "void main() {", "gl_Position = vec4(a_position, 0, 1);", "}"].join("\n");

    Visualize.fragmentShaders = {
      linear: ["precision mediump float;", "uniform vec2 u_resolution;", "uniform sampler2D u_tex;", "uniform vec2 u_extremes;", "void main() {", "vec2 texCoord = gl_FragCoord.xy / u_resolution;", "vec4 pixel_v = texture2D(u_tex, texCoord);", "float min = u_extremes[0];", "float max = u_extremes[1];", "float pixel = (pixel_v[0] - min) / (max - min);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
      logarithm: ["precision mediump float;", "uniform vec2 u_resolution;", "uniform sampler2D u_tex;", "uniform vec2 u_extremes;", "void main() {", "vec2 texCoord = gl_FragCoord.xy / u_resolution;", "vec4 pixel_v = texture2D(u_tex, texCoord);", "float min = log(u_extremes[0]);", "float max = log(u_extremes[1]);", "float pixel = (log(pixel_v[0]) - min) / (max - min);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
      sqrt: ["precision mediump float;", "uniform vec2 u_resolution;", "uniform sampler2D u_tex;", "uniform vec2 u_extremes;", "void main() {", "vec2 texCoord = gl_FragCoord.xy / u_resolution;", "vec4 pixel_v = texture2D(u_tex, texCoord);", "float min = sqrt(u_extremes[0]);", "float max = sqrt(u_extremes[1]);", "float pixel = (sqrt(pixel_v[0]) - min) / (max - min);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
      arcsinh: ["precision mediump float;", "uniform vec2 u_resolution;", "uniform sampler2D u_tex;", "uniform vec2 u_extremes;", "float arcsinh(float value) {", "return log(value + sqrt(1.0 + value * value));", "}", "void main() {", "vec2 texCoord = gl_FragCoord.xy / u_resolution;", "vec4 pixel_v = texture2D(u_tex, texCoord);", "float min = arcsinh(u_extremes[0]);", "float max = arcsinh(u_extremes[1]);", "float value = arcsinh(pixel_v[0]);", "float pixel = (value - min) / (max - min);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
      power: ["precision mediump float;", "uniform vec2 u_resolution;", "uniform sampler2D u_tex;", "uniform vec2 u_extremes;", "void main() {", "vec2 texCoord = gl_FragCoord.xy / u_resolution;", "vec4 pixel_v = texture2D(u_tex, texCoord);", "float min = pow(u_extremes[0], 2.0);", "float max = pow(u_extremes[1], 2.0);", "float pixel = (pow(pixel_v[0], 2.0) - min) / (max - min);", "gl_FragColor = vec4(pixel, pixel, pixel, 1.0);", "}"].join("\n"),
      color: ["precision mediump float;", "uniform vec2 u_resolution;", "uniform sampler2D u_tex_g;", "uniform sampler2D u_tex_r;", "uniform sampler2D u_tex_i;", "uniform vec2 u_extremes;", "float arcsinh(float value) {", "return log(value + sqrt(1.0 + value * value));", "}", "float f(float minimum, float maximum, float value) {", "float pixel = clamp(value, minimum, maximum);", "float alpha = 0.02;", "float Q = 8.0;", "return arcsinh(alpha * Q * (pixel - minimum)) / Q;", "}", "void main() {", "vec2 texCoord = gl_FragCoord.xy / u_resolution;", "vec4 pixel_v_g = texture2D(u_tex_g, texCoord);", "vec4 pixel_v_r = texture2D(u_tex_r, texCoord);", "vec4 pixel_v_i = texture2D(u_tex_i, texCoord);", "float minimum = u_extremes[0];", "float maximum = u_extremes[1];", "float g = pixel_v_g[0];", "float r = pixel_v_r[0];", "float i = pixel_v_i[0];", "float I = (g + r + i) / 3.0;", "float fI = f(minimum, maximum, I);", "float fII = fI / I;", "float R = i * fII;", "float G = r * fII;", "float B = g * fII;", "float RGBmax = max(max(R, G), B);", "if (RGBmax > 1.0) {", "R = R / RGBmax;", "G = G / RGBmax;", "B = B / RGBmax;", "}", "if (I == 0.0) {", "R = 0.0;", "G = 0.0;", "B = 0.0;", "}", "gl_FragColor = vec4(R, G, B, 1.0);", "}"].join("\n")
    };

    function Visualize(imgset, el) {
      var buffer, positionLocation, resolutionLocation, tex, vertexShader;
      this.imgset = imgset;
      this.el = el;
      this.imgset.getExtremes();
      this.width = this.imgset.getWidth();
      this.height = this.imgset.getHeight();
      this.minimum = this.imgset.minimum;
      this.maximum = this.imgset.maximum;
      this.setupUI(this.width, this.height);
      this.gl = this.setupWebGL();
      if (!this.gl) {
        alert("No WebGL");
        return null;
      }
      this.ext = this.gl.getExtension("OES_texture_float");
      if (!this.ext) {
        alert("No OES_texture_float");
        return null;
      }
      vertexShader = this.loadShader(Visualize.vertexShader, this.gl.VERTEX_SHADER);
      this.fragmentShader = this.loadShader(Visualize.fragmentShaders["linear"], this.gl.FRAGMENT_SHADER);
      this.createProgram([vertexShader, this.fragmentShader]);
      this.gl.useProgram(this.program);
      positionLocation = this.gl.getAttribLocation(this.program, "a_position");
      resolutionLocation = this.gl.getUniformLocation(this.program, "u_resolution");
      this.stretchLocation = this.gl.getUniformLocation(this.program, "u_stretch");
      this.gl.uniform2f(resolutionLocation, this.width, this.height);
      this.extremesLocation = this.gl.getUniformLocation(this.program, "u_extremes");
      this.gl.uniform2f(this.extremesLocation, this.minimum, this.maximum);
      buffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), this.gl.STATIC_DRAW);
      this.gl.enableVertexAttribArray(positionLocation);
      this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
      tex = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, this.width, this.height, 0, this.gl.LUMINANCE, this.gl.FLOAT, this.imgset[0].getHDU().data.getFrameWebGL());
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
      this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
      console.log(this.gl.getError());
    }

    Visualize.prototype.setupWebGL = function(opt_attribs) {
      var context, showLink;
      showLink = function(str) {
        var container;
        container = this.canvas.parentNode;
        if (container) {
          return container.innerHTML = this.makeFailHTML(str);
        }
      };
      if (!window.WebGLRenderingContext) {
        showLink(Visualize.GET_A_WEBGL_BROWSER);
        return null;
      }
      context = this.create3DContext(this.canvas, opt_attribs);
      if (!context) {
        showLink(Visualize.OTHER_PROBLEM);
      }
      return context;
    };

    Visualize.prototype.create3DContext = function(opt_attribs) {
      var context, index, name, names, _i, _len;
      names = ["webgl", "experimental-webgl"];
      context = null;
      for (index = _i = 0, _len = names.length; _i < _len; index = ++_i) {
        name = names[index];
        try {
          context = this.canvas.getContext(name, opt_attribs);
        } catch (e) {

        }
        if (context) {
          break;
        }
      }
      return context;
    };

    Visualize.prototype.makeFailHTML = function(msg) {
      return '' + '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' + '<td align="center">' + '<div style="display: table-cell; vertical-align: middle;">' + '<div style="">' + msg + '</div>' + '</div>' + '</td></tr></table>';
    };

    Visualize.prototype.createProgram = function(shaders, opt_attribs, opt_locations) {
      var attribute, index, linked, options, shader, _i, _j, _len, _len1;
      this.program = this.gl.createProgram();
      for (index = _i = 0, _len = shaders.length; _i < _len; index = ++_i) {
        shader = shaders[index];
        this.gl.attachShader(this.program, shader);
      }
      if (opt_attribs != null) {
        for (index = _j = 0, _len1 = opt_attribs.length; _j < _len1; index = ++_j) {
          attribute = opt_attribs[index];
          options = opt_locations != null ? opt_locations[index] : index;
          this.gl.bindAttribLocation(this.program, options, attribute);
        }
      }
      this.gl.linkProgram(this.program);
      linked = this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS);
      if (!linked) {
        throw "Error in program linking: " + (this.gl.getProgramInfoLog(this.program));
        this.gl.deleteProgram(this.program);
        return null;
      }
    };

    Visualize.prototype.loadShader = function(shaderSource, shaderType) {
      var compiled, lastError, shader;
      shader = this.gl.createShader(shaderType);
      this.gl.shaderSource(shader, shaderSource);
      this.gl.compileShader(shader);
      compiled = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);
      if (!compiled) {
        lastError = this.gl.getShaderInfoLog(shader);
        throw "Error compiling shader " + shader + ": " + lastError;
        this.gl.deleteShader(shader);
        return null;
      }
      return shader;
    };

    Visualize.prototype.setupUI = function(width, height) {
      var container, parent;
      container = document.getElementById(this.el.getAttribute("id"));
      if (container !== null) {
        while (container.children.length > 0) {
          container.removeChild(container.children[0]);
        }
      }
      parent = document.createElement("div");
      parent.setAttribute("class", "fits-viewer");
      this.canvas = document.createElement("canvas");
      this.canvas.setAttribute("width", width);
      this.canvas.setAttribute("height", height);
      this.el.appendChild(parent);
      return parent.appendChild(this.canvas);
    };

    Visualize.prototype.scale = function(minimum, maximum) {
      this.gl.uniform2f(this.extremesLocation, minimum, maximum);
      return this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    };

    Visualize.prototype.stretch = function(value) {
      this.gl.detachShader(this.program, this.fragmentShader);
      this.gl.deleteShader(this.fragmentShader);
      this.fragmentShader = this.loadShader(Visualize.fragmentShaders[value], this.gl.FRAGMENT_SHADER);
      this.gl.attachShader(this.program, this.fragmentShader);
      return this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    };

    return Visualize;

  })();

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Visualize;
  }

}).call(this);
}});
