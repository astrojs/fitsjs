// Generated by CoffeeScript 1.6.0
(function() {
  var BinaryTable, CompressedImage, DataUnit, Decompress, FITS, File, HDU, Header, HeaderVerify, Image, ImageUtils, Module, Table, Tabular, moduleKeywords,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    _this = this;

  if (this.astro == null) {
    this.astro = {};
  }

  FITS = {};

  FITS.version = '0.4.0';

  this.astro.FITS = FITS;

  moduleKeywords = ['included', 'extended'];

  Module = (function() {

    function Module() {}

    Module.include = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'include(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((_ref = obj.included) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.extend = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'extend(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((_ref = obj.extended) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    Module.prototype.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    return Module;

  })();

  this.astro.FITS.Module = Module;

  DataUnit = (function(_super) {

    __extends(DataUnit, _super);

    DataUnit.swapEndian = {
      B: function(value) {
        return value;
      },
      I: function(value) {
        return (value << 8) | (value >> 8);
      },
      J: function(value) {
        return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);
      }
    };

    DataUnit.swapEndian[8] = DataUnit.swapEndian['B'];

    DataUnit.swapEndian[16] = DataUnit.swapEndian['I'];

    DataUnit.swapEndian[32] = DataUnit.swapEndian['J'];

    function DataUnit(header, view, offset) {
      this.view = view;
      this.offset = offset;
      this.begin = this.offset;
    }

    return DataUnit;

  })(Module);

  this.astro.FITS.DataUnit = DataUnit;

  HeaderVerify = {
    verifyOrder: function(keyword, order) {
      if (order !== this.cardIndex) {
        return console.warn("" + keyword + " should appear at index " + this.cardIndex + " in the FITS header");
      }
    },
    verifyBetween: function(keyword, value, lower, upper) {
      if (!(value >= lower && value <= upper)) {
        throw "The " + keyword + " value of " + value + " is not between " + lower + " and " + upper;
      }
    },
    verifyBoolean: function(value) {
      if (value === "T") {
        return true;
      } else {
        return false;
      }
    },
    VerifyFns: {
      SIMPLE: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.primary = true;
        this.verifyOrder("SIMPLE", 0);
        return this.verifyBoolean(value);
      },
      XTENSION: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        this.extension = true;
        this.extensionType = arguments[0];
        this.verifyOrder("XTENSION", 0);
        return this.extensionType;
      },
      BITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BITPIX";
        value = parseInt(arguments[0]);
        this.verifyOrder(key, 1);
        if (value !== 8 && value !== 16 && value !== 32 && value !== (-32)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return value;
      },
      NAXIS: function() {
        var args, array, key, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "NAXIS";
        value = parseInt(arguments[0]);
        array = arguments[1];
        if (!array) {
          this.verifyOrder(key, 2);
          this.verifyBetween(key, value, 0, 999);
          if (this.isExtension()) {
            if ((_ref = this.extensionType) === "TABLE" || _ref === "BINTABLE") {
              required = 2;
              if (value !== required) {
                throw "" + key + " must be " + required + " for TABLE and BINTABLE extensions";
              }
            }
          }
        }
        return value;
      },
      PCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "PCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this.get("NAXIS");
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE") {
            required = 0;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      GCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "GCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this.get("NAXIS") + 1;
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE" || _ref === "BINTABLE") {
            required = 1;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      EXTEND: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        if (!this.isPrimary()) {
          throw "EXTEND must only appear in the primary header";
        }
        return this.verifyBoolean(value);
      },
      BSCALE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BZERO: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BLANK: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        if (!(this.get("BIXPIX") > 0)) {
          throw "BLANK is not to be used for BITPIX = " + (this.get('BITPIX'));
        }
        return parseInt(value);
      },
      DATAMIN: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      DATAMAX: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      EXTVER: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseInt(arguments[0]);
      },
      EXTLEVEL: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseInt(arguments[0]);
      },
      TFIELDS: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = parseInt(arguments[0]);
        this.verifyBetween("TFIELDS", value, 0, 999);
        return value;
      },
      TBCOL: function() {
        var args, index, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        index = arguments[2];
        this.verifyBetween("TBCOL", index, 0, this.get("TFIELDS"));
        return value;
      },
      ZIMAGE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return this.verifyBoolean(arguments[0]);
      },
      ZCMPTYPE: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        if (value !== 'GZIP_1' && value !== 'RICE_1' && value !== 'PLIO_1' && value !== 'HCOMPRESS_1') {
          throw "ZCMPTYPE value " + value + " is not permitted";
        }
        if (value !== 'RICE_1') {
          throw "Compress type " + value + " is not yet implement";
        }
        return value;
      },
      ZBITPIX: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = parseInt(arguments[0]);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "ZBITPIX value " + value + " is not permitted";
        }
        return value;
      },
      ZNAXIS: function() {
        var args, array, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = parseInt(arguments[0]);
        array = arguments[1];
        value = value;
        if (!array) {
          this.verifyBetween("ZNAXIS", value, 0, 999);
        }
        return value;
      },
      ZTILE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseInt(arguments[0]);
      },
      ZSIMPLE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (arguments[0] === "T") {
          return true;
        } else {
          return false;
        }
      },
      ZPCOUNT: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseInt(arguments[0]);
      },
      ZGCOUNT: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseInt(arguments[0]);
      }
    }
  };

  this.astro.FITS.HeaderVerify = HeaderVerify;

  Header = (function(_super) {

    __extends(Header, _super);

    Header.include(HeaderVerify);

    Header.prototype.arrayPattern = /(\D+)(\d+)/;

    Header.prototype.maxLines = 600;

    function Header(block) {
      var method, name, _ref;
      this.primary = false;
      this.extension = false;
      this.verifyCard = {};
      _ref = this.VerifyFns;
      for (name in _ref) {
        method = _ref[name];
        this.verifyCard[name] = this.proxy(method);
      }
      this.cards = {};
      this.cards["COMMENT"] = [];
      this.cards["HISTORY"] = [];
      this.cardIndex = 0;
      this.readBlock(block);
    }

    Header.prototype.get = function(key) {
      if (this.contains(key)) {
        return this.cards[key].value;
      } else {
        return null;
      }
    };

    Header.prototype.set = function(key, value, comment) {
      comment = comment || '';
      this.cards[key] = {
        index: this.cardIndex,
        value: value,
        comment: comment
      };
      return this.cardIndex += 1;
    };

    Header.prototype.contains = function(key) {
      return this.cards.hasOwnProperty(key);
    };

    Header.prototype.readLine = function(l) {
      var blank, comment, firstByte, indicator, key, value, _ref;
      key = l.slice(0, 8).trim();
      blank = key === '';
      if (blank) {
        return;
      }
      indicator = l.slice(8, 10);
      value = l.slice(10);
      if (indicator !== "= ") {
        if (key === 'COMMENT' || key === 'HISTORY') {
          this.cards[key].push(value.trim());
        }
        return;
      }
      _ref = value.split(' /'), value = _ref[0], comment = _ref[1];
      value = value.trim();
      firstByte = value[0];
      if (firstByte === "'") {
        value = value.slice(1, -1).trim();
      } else {
        if (value !== 'T' && value !== 'F') {
          value = parseFloat(value);
        }
      }
      value = this.validate(key, value);
      return this.set(key, value, comment);
    };

    Header.prototype.validate = function(key, value) {
      var baseKey, index, isArray, match, _ref;
      index = null;
      baseKey = key;
      isArray = this.arrayPattern.test(key);
      if (isArray) {
        match = this.arrayPattern.exec(key);
        _ref = match.slice(1), baseKey = _ref[0], index = _ref[1];
      }
      if (baseKey in this.verifyCard) {
        value = this.verifyCard[baseKey](value, isArray, index);
      }
      return value;
    };

    Header.prototype.readBlock = function(block) {
      var i, line, lineWidth, nLines, _i, _ref, _results;
      lineWidth = 80;
      nLines = block.length / lineWidth;
      nLines = nLines < this.maxLines ? nLines : this.maxLines;
      _results = [];
      for (i = _i = 0, _ref = nLines - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = block.slice(i * lineWidth, (i + 1) * lineWidth);
        _results.push(this.readLine(line));
      }
      return _results;
    };

    Header.prototype.hasDataUnit = function() {
      if (this.get("NAXIS") === 0) {
        return false;
      } else {
        return true;
      }
    };

    Header.prototype.getDataLength = function() {
      var i, length, naxis, _i, _ref;
      if (!this.hasDataUnit()) {
        return 0;
      }
      naxis = [];
      for (i = _i = 1, _ref = this.get("NAXIS"); 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        naxis.push(this.get("NAXIS" + i));
      }
      length = naxis.reduce(function(a, b) {
        return a * b;
      }) * Math.abs(this.get("BITPIX")) / 8;
      length += this.get("PCOUNT");
      return length;
    };

    Header.prototype.getDataType = function() {
      switch (this.extensionType) {
        case 'BINTABLE':
          if (this.contains('ZIMAGE')) {
            return 'CompressedImage';
          }
          return 'BinaryTable';
        case 'TABLE':
          return 'Table';
        default:
          if (this.hasDataUnit()) {
            return 'Image';
          } else {
            return null;
          }
      }
    };

    Header.prototype.isPrimary = function() {
      return this.primary;
    };

    Header.prototype.isExtension = function() {
      return this.extension;
    };

    return Header;

  })(Module);

  this.astro.FITS.Header = Header;

  ImageUtils = {
    getExtent: function(arr) {
      var index, max, min, value, _ref, _ref1;
      if ((this.min != null) && (this.max != null)) {
        return [this.min, this.max];
      }
      index = arr.length;
      while (index--) {
        value = arr[index];
        if (isNaN(value)) {
          continue;
        }
        _ref = [value, value], min = _ref[0], max = _ref[1];
        break;
      }
      while (index--) {
        value = arr[index];
        if (isNaN(value)) {
          continue;
        }
        if (value < min) {
          min = value;
        }
        if (value > max) {
          max = value;
        }
      }
      _ref1 = [min, max], this.min = _ref1[0], this.max = _ref1[1];
      return [this.min, this.max];
    },
    getPixel: function(arr, x, y) {
      return arr[y * this.width + x];
    }
  };

  this.astro.FITS.ImageUtils = ImageUtils;

  Image = (function(_super) {

    __extends(Image, _super);

    Image.include(ImageUtils);

    Image.prototype.chunkSize = 536870912;

    function Image() {
      var header, i, naxis, offset, view, _i;
      if (arguments.length === 3) {
        Image.__super__.constructor.apply(this, arguments);
        header = arguments[0], view = arguments[1], offset = arguments[2];
      } else {
        this.begin = this.offset = 0;
        header = arguments[0], this.blob = arguments[1];
      }
      naxis = header.get("NAXIS");
      this.bitpix = header.get("BITPIX");
      this.naxis = [];
      for (i = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; i = 1 <= naxis ? ++_i : --_i) {
        this.naxis.push(header.get("NAXIS" + i));
      }
      this.width = header.get("NAXIS1");
      this.height = header.get("NAXIS2") || 1;
      this.bzero = header.get("BZERO") || 0;
      this.bscale = header.get("BSCALE") || 1;
      this.bytes = Math.abs(this.bitpix) / 8;
      this.length = this.naxis.reduce(function(a, b) {
        return a * b;
      }) * Math.abs(this.bitpix) / 8;
      this.frame = 0;
    }

    Image.prototype.start = function(callback, context, args) {
      var buffer, chunk, i, lastChunkSize, nChunks, reader,
        _this = this;
      if (this.blob == null) {
        context = context != null ? context : this;
        if (callback != null) {
          callback.apply(context, [args]);
        }
        return;
      }
      reader = new FileReader();
      i = 1;
      nChunks = Math.floor(this.blob.size / this.chunkSize) - 1;
      lastChunkSize = this.blob.size - this.chunkSize * nChunks;
      buffer = [];
      reader.onloadend = function(e) {
        var begin, end;
        console.log('onloadend');
        buffer.push(e.target.result);
        console.log(buffer);
        while (nChunks--) {
          begin = _this.chunkSize * i;
          end = begin + _this.chunkSize;
          console.log(begin, end);
          i += 1;
        }
        context = context != null ? context : _this;
        if (callback != null) {
          return callback.apply(context, [args]);
        }
      };
      console.log(0, this.chunkSize);
      chunk = this.blob.slice(0, this.chunkSize);
      return reader.readAsArrayBuffer(chunk);
    };

    Image._getFrame = function(buffer, width, height, offset, frame, bytes, bitpix, bzero, bscale) {
      var arr, chunk, dataType, i, nPixels, start, swapEndian, value;
      nPixels = i = width * height;
      start = offset + (frame * nPixels * bytes);
      chunk = buffer.slice(start, start + nPixels * bytes);
      dataType = Math.abs(bitpix);
      if (bitpix > 0) {
        switch (bitpix) {
          case 8:
            arr = new Uint8Array(chunk);
            arr = new Uint16Array(arr);
            swapEndian = function(value) {
              return value;
            };
            break;
          case 16:
            arr = new Uint16Array(chunk);
            swapEndian = function(value) {
              return (value << 8) | (value >> 8);
            };
            break;
          case 32:
            arr = new Int32Array(chunk);
            swapEndian = function(value) {
              return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);
            };
        }
        while (nPixels--) {
          value = arr[nPixels];
          value = swapEndian(value);
          arr[nPixels] = bzero + bscale * value + 0.5;
        }
      } else {
        arr = new Uint32Array(chunk);
        swapEndian = function(value) {
          return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);
        };
        while (i--) {
          value = arr[i];
          arr[i] = swapEndian(value);
        }
        arr = new Float32Array(chunk);
        while (nPixels--) {
          arr[nPixels] = bzero + bscale * arr[nPixels];
        }
      }
      return arr;
    };

    Image.prototype.getFrameAsync = function(frame, callback, opts) {
      var URL, blobGetFrame, blobOnMessage, fn1, fn2, mime, msg, onmessage, urlGetFrame, urlOnMessage, worker;
      this.frame = frame != null ? frame : this.frame;
      if (opts == null) {
        opts = void 0;
      }
      onmessage = function(e) {
        var arr, bitpix, bscale, buffer, bytes, bzero, data, height, offset, url, width;
        data = e.data;
        buffer = data.buffer;
        width = data.width;
        height = data.height;
        offset = data.offset;
        frame = data.frame;
        bytes = data.bytes;
        bitpix = data.bitpix;
        bzero = data.bzero;
        bscale = data.bscale;
        url = data.url;
        importScripts(url);
        arr = _getFrame(buffer, width, height, offset, frame, bytes, bitpix, bzero, bscale);
        return postMessage(arr);
      };
      fn1 = onmessage.toString().replace('return postMessage(data);', 'postMessage(data);');
      fn1 = "onmessage = " + fn1;
      fn2 = Image._getFrame.toString();
      fn2 = fn2.replace('function', 'function _getFrame');
      mime = "application/javascript";
      blobOnMessage = new Blob([fn1], {
        type: mime
      });
      blobGetFrame = new Blob([fn2], {
        type: mime
      });
      URL = window.URL || window.webkitURL || window.MozURLProperty;
      urlOnMessage = URL.createObjectURL(blobOnMessage);
      urlGetFrame = URL.createObjectURL(blobGetFrame);
      worker = new Worker(urlOnMessage);
      worker.onmessage = function(e) {
        var arr, context;
        arr = e.data;
        context = (opts != null ? opts.context : void 0) != null ? opts.context : this;
        if (callback != null) {
          callback.call(context, arr, opts);
        }
        URL.revokeObjectURL(urlOnMessage);
        URL.revokeObjectURL(urlGetFrame);
        return worker.terminate();
      };
      msg = {};
      msg.buffer = this.view.buffer;
      msg.width = this.width;
      msg.height = this.height;
      msg.offset = this.offset;
      msg.frame = this.frame;
      msg.bytes = this.bytes;
      msg.bitpix = this.bitpix;
      msg.bzero = this.bzero;
      msg.bscale = this.bscale;
      msg.url = urlGetFrame;
      return worker.postMessage(msg);
    };

    Image.prototype.getFrame = function(frame) {
      var arr;
      this.frame = frame != null ? frame : this.frame;
      arr = Image._getFrame(this.view.buffer, this.width, this.height, this.offset, this.frame, this.bytes, this.bitpix, this.bzero, this.bscale);
      if (this.isDataCube()) {
        this.frame += 1;
      }
      return arr;
    };

    Image.prototype.isDataCube = function() {
      if (this.naxis.length > 2) {
        return true;
      } else {
        return false;
      }
    };

    return Image;

  })(DataUnit);

  this.astro.FITS.Image = Image;

  Tabular = (function(_super) {

    __extends(Tabular, _super);

    Tabular.prototype.typedArray = {
      B: Uint8Array,
      I: Uint16Array,
      J: Int32Array,
      E: Float32Array,
      D: Float64Array,
      1: Uint8Array,
      2: Uint16Array,
      4: Int32Array
    };

    Tabular.prototype.dataAccessors = {
      L: function(view, offset) {
        var val, x;
        x = view.getInt8(offset);
        offset += 1;
        val = x === 84 ? true : false;
        return [val, offset];
      },
      B: function(view, offset) {
        var val;
        val = view.getUint8(offset);
        offset += 1;
        return [val, offset];
      },
      I: function(view, offset) {
        var val;
        val = view.getInt16(offset);
        offset += 2;
        return [val, offset];
      },
      J: function(view, offset) {
        var val;
        val = view.getInt32(offset);
        offset += 4;
        return [val, offset];
      },
      K: function(view, offset) {
        var factor, highByte, lowByte, mod, val;
        highByte = Math.abs(view.getInt32(offset));
        offset += 4;
        lowByte = Math.abs(view.getInt32(offset));
        offset += 4;
        mod = highByte % 10;
        factor = mod ? -1 : 1;
        highByte -= mod;
        console.warn("Precision for 64 bit integers may be incorrect.");
        val = factor * ((highByte << 32) | lowByte);
        return [val, offset];
      },
      A: function(view, offset) {
        var val;
        val = view.getChar(offset);
        offset += 1;
        return [val, offset];
      },
      E: function(view, offset) {
        var val;
        val = view.getFloat32(offset);
        offset += 4;
        return [val, offset];
      },
      D: function(view, offset) {
        var val;
        val = view.getFloat64(offset);
        offset += 8;
        return [val, offset];
      },
      C: function(view, offset) {
        var val, val1, val2;
        val1 = view.getFloat32(offset);
        offset += 4;
        val2 = view.getFloat32(offset);
        offset += 4;
        val = [val1, val2];
        return [val, offset];
      },
      M: function(view, offset) {
        var val, val1, val2;
        val1 = view.getFloat64(offset);
        offset += 8;
        val2 = view.getFloat64(offset);
        offset += 8;
        val = [val1, val2];
        return [val, offset];
      }
    };

    function Tabular(header, view, offset) {
      Tabular.__super__.constructor.apply(this, arguments);
      this.rowByteSize = header.get("NAXIS1");
      this.rows = header.get("NAXIS2");
      this.cols = header.get("TFIELDS");
      this.length = this.rowByteSize * this.rows;
      this.rowsRead = 0;
      this.columns = this.getColumnNames(header);
      this.accessors = [];
      this.header = header;
    }

    Tabular.prototype.getRow = function(row) {
      var accessor, index, _i, _len, _ref;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.offset = this.begin + this.rowsRead * this.rowByteSize;
      row = {};
      _ref = this.accessors;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        accessor = _ref[index];
        row[this.columns[index]] = accessor();
      }
      this.rowsRead += 1;
      return row;
    };

    Tabular.prototype.getColumnNames = function(header) {
      var columnNames, i, key, _i, _ref;
      columnNames = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        key = "TTYPE" + i;
        if (!header.contains(key)) {
          return null;
        }
        columnNames.push(header.get(key));
      }
      return columnNames;
    };

    return Tabular;

  })(DataUnit);

  this.astro.FITS.Tabular = Tabular;

  Table = (function(_super) {

    __extends(Table, _super);

    Table.prototype.dataAccessors = {
      A: function(value) {
        return value.trim();
      },
      I: function(value) {
        return parseInt(value);
      },
      F: function(value) {
        return parseFloat(value);
      },
      E: function(value) {
        return parseFloat(value);
      },
      D: function(value) {
        return parseFloat(value);
      }
    };

    function Table(header, view, offset) {
      var _this = this;
      this.getRow = function(row) {
        if (row == null) {
          row = null;
        }
        return Table.prototype.getRow.apply(_this, arguments);
      };
      Table.__super__.constructor.apply(this, arguments);
      this.setAccessors(header);
    }

    Table.prototype.setAccessors = function(header) {
      var descriptor, form, i, match, pattern, type, _i, _ref, _results,
        _this = this;
      pattern = /([AIFED])(\d+)\.*(\d+)*/;
      _results = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        form = header.get("TFORM" + i);
        type = header.get("TTYPE" + i);
        match = pattern.exec(form);
        descriptor = match[1];
        _results.push((function(descriptor) {
          var accessor;
          accessor = function(value) {
            return _this.dataAccessors[descriptor](value);
          };
          return _this.accessors.push(accessor);
        })(descriptor));
      }
      return _results;
    };

    Table.prototype.getRow = function(row) {
      var index, line, value, _i, _len;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.offset = this.begin + this.rowsRead * this.rowByteSize;
      line = this.view.getString(this.offset, this.rowByteSize).trim().split(/\s+/);
      row = {};
      for (index = _i = 0, _len = line.length; _i < _len; index = ++_i) {
        value = line[index];
        row[this.columns[index]] = this.accessors[index](value);
      }
      this.offset += this.rowByteSize;
      this.rowsRead += 1;
      return row;
    };

    return Table;

  })(Tabular);

  this.astro.FITS.Table = Table;

  BinaryTable = (function(_super) {

    __extends(BinaryTable, _super);

    function BinaryTable(header, view, offset) {
      var reader, tblCols,
        _this = this;
      BinaryTable.__super__.constructor.apply(this, arguments);
      if (arguments[1] instanceof Blob) {
        reader = new FileReader();
        reader.onloadend = function(e) {
          var tblCols;
          _this.offset = _this.begin = 0;
          _this.view = e.target.result;
          _this.tableLength = _this.length;
          _this.columnNames = {};
          tblCols = _this.getTableColumns(header);
          return _this.setAccessors(tblCols, view);
        };
        reader.readAsArrayBuffer(arguments[1]);
      } else {
        this.tableLength = this.length;
        this.columnNames = {};
        tblCols = this.getTableColumns(header);
        this.setAccessors(tblCols, view);
      }
    }

    BinaryTable.prototype.getTableColumns = function(header) {
      var form, i, obj, parameters, type, _i, _ref;
      parameters = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        obj = {};
        form = header.get("TFORM" + i);
        type = header.get("TTYPE" + i);
        obj[form] = type;
        parameters.push(obj);
        this.columnNames[type] = i - 1;
      }
      return parameters;
    };

    BinaryTable.prototype.toBits = function(byte) {
      var arr, i;
      arr = [];
      i = 128;
      while (i >= 1) {
        arr.push((byte & i ? 1 : 0));
        i /= 2;
      }
      return arr;
    };

    BinaryTable.prototype.getFromHeap = function(descriptor) {
      var arr, chunk, heapOffset, i, length, offset;
      length = this.view.getInt32(this.offset);
      this.offset += 4;
      offset = this.view.getInt32(this.offset);
      this.offset += 4;
      heapOffset = this.begin + this.tableLength + offset;
      chunk = this.view.buffer.slice(heapOffset, heapOffset + length);
      arr = new this.typedArray[descriptor](chunk);
      i = arr.length;
      while (i--) {
        arr[i] = this.constructor.swapEndian[descriptor](arr[i]);
      }
      return arr;
    };

    BinaryTable.prototype.setAccessors = function(tblCols, view) {
      var column, count, descriptor, form, i, isArray, match, pattern, type, _i, _len, _results,
        _this = this;
      pattern = /(\d*)([P|Q]*)([L|X|B|I|J|K|A|E|D|C|M]{1})/;
      _results = [];
      for (i = _i = 0, _len = tblCols.length; _i < _len; i = ++_i) {
        column = tblCols[i];
        form = Object.keys(column)[0];
        type = column[form];
        match = pattern.exec(form);
        count = parseInt(match[1]) || 1;
        isArray = match[2];
        descriptor = match[3];
        if (isArray) {
          switch (type) {
            case "COMPRESSED_DATA":
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  var arr, pixels;
                  arr = _this.getFromHeap(descriptor);
                  pixels = new _this.typedArray[_this.params["BYTEPIX"]](_this.ztile[0]);
                  Decompress.Rice(arr, _this.params["BLOCKSIZE"], _this.params["BYTEPIX"], pixels, _this.ztile[0], Decompress.RiceSetup);
                  return pixels;
                };
                return _this.accessors.push(accessor);
              })(descriptor, count));
              break;
            case "GZIP_COMPRESSED_DATA":
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  var arr;
                  arr = new Float32Array(_this.width);
                  i = arr.length;
                  while (i--) {
                    arr[i] = NaN;
                  }
                  return arr;
                };
                return _this.accessors.push(accessor);
              })(descriptor, count));
              break;
            default:
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  return _this.getFromHeap(descriptor);
                };
                return _this.accessors.push(accessor);
              })(descriptor, count));
          }
        } else {
          if (count === 1) {
            _results.push((function(descriptor, count) {
              var accessor;
              accessor = function() {
                var value, _ref;
                _ref = _this.dataAccessors[descriptor](view, _this.offset), value = _ref[0], _this.offset = _ref[1];
                return value;
              };
              return _this.accessors.push(accessor);
            })(descriptor, count));
          } else {
            if (descriptor === 'X') {
              _results.push((function(descriptor, count) {
                var accessor, nBytes;
                nBytes = Math.log(count) / Math.log(2);
                accessor = function() {
                  var arr, bits, byte, bytes, chunk, _j, _len1;
                  chunk = view.buffer.slice(_this.offset, _this.offset + nBytes);
                  bytes = new Uint8Array(chunk);
                  bits = [];
                  for (_j = 0, _len1 = bytes.length; _j < _len1; _j++) {
                    byte = bytes[_j];
                    arr = _this.toBits(byte);
                    bits = bits.concat(arr);
                  }
                  _this.offset += nBytes;
                  return bits.slice(0, +(count - 1) + 1 || 9e9);
                };
                return _this.accessors.push(accessor);
              })(descriptor, count));
            } else if (descriptor === 'A') {
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  var str;
                  str = view.getString(_this.offset, count);
                  _this.offset += count;
                  return str.trim();
                };
                return _this.accessors.push(accessor);
              })(descriptor, count));
            } else {
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  var data, value, _ref;
                  data = [];
                  while (count--) {
                    _ref = _this.dataAccessors[descriptor](view, _this.offset), value = _ref[0], _this.offset = _ref[1];
                    data.push(value);
                  }
                  return data;
                };
                return _this.accessors.push(accessor);
              })(descriptor, count));
            }
          }
        }
      }
      return _results;
    };

    return BinaryTable;

  })(Tabular);

  this.astro.FITS.BinaryTable = BinaryTable;

  Decompress = {
    RiceSetup: {
      1: function(array) {
        var fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 3;
        fsmax = 6;
        lastpix = array[pointer];
        pointer += 1;
        return [fsbits, fsmax, lastpix, pointer];
      },
      2: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 4;
        fsmax = 14;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      },
      4: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 5;
        fsmax = 25;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 24);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 16);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      }
    },
    Rice: function(array, blocksize, bytepix, pixels, nx, setup) {
      var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer, _ref, _ref1;
      bbits = 1 << fsbits;
      _ref = setup[bytepix](array), fsbits = _ref[0], fsmax = _ref[1], lastpix = _ref[2], pointer = _ref[3];
      nonzeroCount = new Uint8Array(256);
      nzero = 8;
      _ref1 = [128, 255], k = _ref1[0], i = _ref1[1];
      while (i >= 0) {
        while (i >= k) {
          nonzeroCount[i] = nzero;
          i -= 1;
        }
        k = k / 2;
        nzero -= 1;
      }
      nonzeroCount[0] = 0;
      b = array[pointer];
      pointer += 1;
      nbits = 8;
      i = 0;
      while (i < nx) {
        nbits -= fsbits;
        while (nbits < 0) {
          b = (b << 8) | array[pointer];
          pointer += 1;
          nbits += 8;
        }
        fs = (b >> nbits) - 1;
        b &= (1 << nbits) - 1;
        imax = i + blocksize;
        if (imax > nx) {
          imax = nx;
        }
        if (fs < 0) {
          while (i < imax) {
            array[i] = lastpix;
            i++;
          }
        } else if (fs === fsmax) {
          while (i < imax) {
            k = bbits - nbits;
            diff = b << k;
            k -= 8;
            while (k >= 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b << k;
              k -= 8;
            }
            if (nbits > 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b >> (-k);
              b &= (1 << nbits) - 1;
            } else {
              b = 0;
            }
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            array[i] = diff + lastpix;
            lastpix = array[i];
            i++;
          }
        } else {
          while (i < imax) {
            while (b === 0) {
              nbits += 8;
              b = array[pointer];
              pointer += 1;
            }
            nzero = nbits - nonzeroCount[b];
            nbits -= nzero + 1;
            b ^= 1 << nbits;
            nbits -= fs;
            while (nbits < 0) {
              b = (b << 8) | array[pointer];
              pointer += 1;
              nbits += 8;
            }
            diff = (nzero << fs) | (b >> nbits);
            b &= (1 << nbits) - 1;
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            pixels[i] = diff + lastpix;
            lastpix = pixels[i];
            i++;
          }
        }
      }
      return pixels;
    }
  };

  this.astro.FITS.Decompress = Decompress;

  CompressedImage = (function(_super) {

    __extends(CompressedImage, _super);

    CompressedImage.include(ImageUtils);

    CompressedImage.extend(Decompress);

    function CompressedImage(header, view, offset) {
      var i, key, value, ztile, _i, _ref;
      CompressedImage.__super__.constructor.apply(this, arguments);
      this.length += header.get("PCOUNT");
      this.zcmptype = header.get("ZCMPTYPE");
      this.zbitpix = header.get("ZBITPIX");
      this.znaxis = header.get("ZNAXIS");
      this.zblank = this.getValue(header, "ZBLANK", void 0);
      this.blank = this.getValue(header, "BLANK", void 0);
      this.zdither = header.get('ZDITHER0') || 0;
      this.ztile = [];
      for (i = _i = 1, _ref = this.znaxis; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        ztile = header.contains("ZTILE" + i) ? header.get("ZTILE" + i) : i === 1 ? header.get("ZNAXIS1") : 1;
        this.ztile.push(ztile);
      }
      this.width = header.get("ZNAXIS1");
      this.height = header.get("ZNAXIS2") || 1;
      this.params = {};
      i = 1;
      while (true) {
        key = "ZNAME" + i;
        if (!header.contains(key)) {
          break;
        }
        value = "ZVAL" + i;
        this.params[header.get(key)] = header.get(value);
        i += 1;
      }
      if (this.zcmptype === 'RICE_1') {
        this.setRiceDefaults();
      }
      this.zmaskcmp = this.getValue(header, "ZMASKCMP", void 0);
      this.zquantiz = this.getValue(header, "ZQUANTIZ", "LINEAR_SCALING");
      this.bzero = this.getValue(header, "BZERO", 0);
      this.bscale = this.getValue(header, "BSCALE", 1);
      this.tableColumns = this.getTableColumns(header);
      this.setAccessors(this.tableColumns, view);
      this.defGetRow();
      this.randomSeq = this.randomGenerator();
    }

    CompressedImage.prototype.getValue = function(header, key, defaultValue) {
      if (header.contains(key)) {
        return header.get(key);
      } else {
        return defaultValue;
      }
    };

    CompressedImage.prototype.setRiceDefaults = function() {
      if (!("BLOCKSIZE" in this.params)) {
        this.params["BLOCKSIZE"] = 32;
      }
      if (!("BYTEPIX" in this.params)) {
        return this.params["BYTEPIX"] = 4;
      }
    };

    CompressedImage.prototype.defGetRow = function() {
      var hasBlanks;
      hasBlanks = (this.zblank != null) || (this.blank != null) || this.columnNames.hasOwnProperty("ZBLANK");
      return this.getRow = hasBlanks ? this.getRowHasBlanks : this.getRowNoBlanks;
    };

    CompressedImage.prototype.getRowHasBlanks = function(arr) {
      var blank, data, ditherOffset, i, index, offset, r, random, scale, value, zero, _i, _len, _ref;
      _ref = this.getTableRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      random = this.random;
      ditherOffset = this.ditherOffset;
      offset = this.rowsRead * this.width;
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        i = offset + index;
        r = random[ditherOffset];
        arr[i] = value === blank ? NaN : (value - r + 0.5) * scale + zero;
        ditherOffset = (ditherOffset + 1) % 10000;
      }
      return this.rowsRead += 1;
    };

    CompressedImage.prototype.getRowNoBlanks = function(arr) {
      var blank, data, i, index, offset, rIndex, scale, seed0, seed1, value, zero, _i, _len, _ref;
      _ref = this.getTableRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      seed0 = this.rowsRead + this.zdither - 1;
      seed1 = (seed0 - 1) % 10000;
      rIndex = parseInt(this.randomSeq[seed1] * 500);
      offset = this.rowsRead * this.width;
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        i = offset + index;
        if (value === -2147483647) {
          arr[i] = NaN;
        } else if (value === -2147483646) {
          arr[i] = 0;
        } else {
          if (this.rowsRead === 0) {
            console.log(this.randomSeq[rIndex]);
          }
          arr[i] = (value - this.randomSeq[rIndex] + 0.5) * scale + zero;
        }
        rIndex += 1;
        if (rIndex === 10000) {
          seed1 = (seed1 + 1) % 10000;
          rIndex = parseInt(this.randomSeq[seed1] * 500);
        }
      }
      return this.rowsRead += 1;
    };

    CompressedImage.prototype.getTableRow = function() {
      var accessor, blank, data, row, scale, zero, _i, _len, _ref;
      this.offset = this.begin + this.rowsRead * this.rowByteSize;
      row = [];
      _ref = this.accessors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        accessor = _ref[_i];
        row.push(accessor());
      }
      data = row[this.columnNames["COMPRESSED_DATA"]] || row[this.columnNames["UNCOMPRESSED_DATA"]] || row[this.columnNames["GZIP_COMPRESSED_DATA"]];
      blank = row[this.columnNames["ZBLANK"]] || this.zblank;
      scale = row[this.columnNames["ZSCALE"]] || this.bscale;
      zero = row[this.columnNames["ZZERO"]] || this.bzero;
      return [data, blank, scale, zero];
    };

    CompressedImage.prototype.getFrame = function() {
      var arr, height;
      arr = new Float32Array(this.width * this.height);
      this.rowsRead = 0;
      height = this.height;
      while (height--) {
        this.getRow(arr);
      }
      return arr;
    };

    CompressedImage.prototype.randomGenerator = function() {
      var a, i, m, random, seed, temp, _i;
      a = 16807;
      m = 2147483647;
      seed = 1;
      random = new Float32Array(10000);
      for (i = _i = 0; _i <= 9999; i = ++_i) {
        temp = a * seed;
        seed = temp - m * parseInt(temp / m);
        random[i] = seed / m;
      }
      return random;
    };

    CompressedImage.prototype.getRandom = function(nTile) {
      var offset, r;
      nTile = nTile % 10000;
      r = this.random[nTile];
      offset = parseInt(500 * r);
      return this.random[offset];
    };

    return CompressedImage;

  })(BinaryTable);

  this.astro.FITS.CompressedImage = CompressedImage;

  CompressedImage = this.astro.FITS.CompressedImage;

  CompressedImage.prototype.getFrameAsync = function(frame, callback, opts) {
    var URL, blobOnMessage, blobRice, data, fn1, fn2, mime, onmessage, urlOnMessage, urlRice, worker;
    this.frame = frame != null ? frame : this.frame;
    if (opts == null) {
      opts = void 0;
    }
    onmessage = function(e) {
      var RiceSetup, accessors, arr, bitpix, blank, bscale, buffer, bzero, columnNames, data, dataAccessors, defGetRow, getFrame, getFromHeap, getRow, getRowHasBlanks, getRowNoBlanks, getTableRow, height, offset, params, rowByteSize, rowsRead, setAccessors, swapEndian, tableColumns, tableLength, typedArray, urlRice, view, width, zblank, ztile;
      data = e.data;
      tableLength = data.tableLength;
      tableColumns = data.tableColumns;
      columnNames = data.columnNames;
      params = data.params;
      ztile = data.ztile;
      rowByteSize = data.rowByteSize;
      zblank = data.zblank;
      bscale = data.bscale;
      bzero = data.bzero;
      width = data.width;
      height = data.height;
      blank = data.blank;
      bitpix = data.bitpix;
      buffer = data.buffer;
      urlRice = data.urlRice;
      dataAccessors = {
        L: function(view, offset) {
          var val, x;
          x = view.getInt8(offset);
          offset += 1;
          val = x === 84 ? true : false;
          return [val, offset];
        },
        B: function(view, offset) {
          var val;
          val = view.getUint8(offset);
          offset += 1;
          return [val, offset];
        },
        I: function(view, offset) {
          var val;
          val = view.getInt16(offset);
          offset += 2;
          return [val, offset];
        },
        J: function(view, offset) {
          var val;
          val = view.getInt32(offset);
          offset += 4;
          return [val, offset];
        },
        K: function(view, offset) {
          var factor, highByte, lowByte, mod, val;
          highByte = Math.abs(view.getInt32(offset));
          offset += 4;
          lowByte = Math.abs(view.getInt32(offset));
          offset += 4;
          mod = highByte % 10;
          factor = mod ? -1 : 1;
          highByte -= mod;
          console.warn("Precision for 64 bit integers may be incorrect.");
          val = factor * ((highByte << 32) | lowByte);
          return [val, offset];
        },
        A: function(view, offset) {
          var val;
          val = view.getChar(offset);
          offset += 1;
          return [val, offset];
        },
        E: function(view, offset) {
          var val;
          val = view.getFloat32(offset);
          offset += 4;
          return [val, offset];
        },
        D: function(view, offset) {
          var val;
          val = view.getFloat64(offset);
          offset += 8;
          return [val, offset];
        },
        C: function(view, offset) {
          var val, val1, val2;
          val1 = view.getFloat32(offset);
          offset += 4;
          val2 = view.getFloat32(offset);
          offset += 4;
          val = [val1, val2];
          return [val, offset];
        },
        M: function(view, offset) {
          var val, val1, val2;
          val1 = view.getFloat64(offset);
          offset += 8;
          val2 = view.getFloat64(offset);
          offset += 8;
          val = [val1, val2];
          return [val, offset];
        }
      };
      RiceSetup = {
        1: function(array) {
          var fsbits, fsmax, lastpix, pointer;
          pointer = 0;
          fsbits = 3;
          fsmax = 6;
          lastpix = array[pointer];
          pointer += 1;
          return [fsbits, fsmax, lastpix, pointer];
        },
        2: function(array) {
          var bytevalue, fsbits, fsmax, lastpix, pointer;
          pointer = 0;
          fsbits = 4;
          fsmax = 14;
          lastpix = 0;
          bytevalue = array[pointer];
          pointer += 1;
          lastpix = lastpix | (bytevalue << 8);
          bytevalue = array[pointer];
          pointer += 1;
          lastpix = lastpix | bytevalue;
          return [fsbits, fsmax, lastpix, pointer];
        },
        4: function(array) {
          var bytevalue, fsbits, fsmax, lastpix, pointer;
          pointer = 0;
          fsbits = 5;
          fsmax = 25;
          lastpix = 0;
          bytevalue = array[pointer];
          pointer += 1;
          lastpix = lastpix | (bytevalue << 24);
          bytevalue = array[pointer];
          pointer += 1;
          lastpix = lastpix | (bytevalue << 16);
          bytevalue = array[pointer];
          pointer += 1;
          lastpix = lastpix | (bytevalue << 8);
          bytevalue = array[pointer];
          pointer += 1;
          lastpix = lastpix | bytevalue;
          return [fsbits, fsmax, lastpix, pointer];
        }
      };
      importScripts(urlRice);
      typedArray = {
        B: Uint8Array,
        I: Uint16Array,
        J: Int32Array,
        E: Float32Array,
        D: Float64Array,
        1: Uint8Array,
        2: Uint16Array,
        4: Int32Array
      };
      offset = 0;
      rowsRead = 0;
      accessors = [];
      view = new DataView(buffer);
      switch (Math.abs(bitpix)) {
        case 16:
          swapEndian = function(value) {
            return (value << 8) | (value >> 8);
          };
          break;
        case 32:
          swapEndian = function(value) {
            return ((value & 0xFF) << 24) | ((value & 0xFF00) << 8) | ((value >> 8) & 0xFF00) | ((value >> 24) & 0xFF);
          };
          break;
        default:
          swapEndian = function(value) {
            return value;
          };
      }
      getFromHeap = function(descriptor) {
        var arr, chunk, chunkOffset, heapOffset, i, length;
        length = view.getInt32(offset);
        offset += 4;
        heapOffset = view.getInt32(offset);
        offset += 4;
        chunkOffset = tableLength + heapOffset;
        chunk = view.buffer.slice(chunkOffset, chunkOffset + length);
        arr = new typedArray[descriptor](chunk);
        i = arr.length;
        while (i--) {
          arr[i] = swapEndian(arr[i]);
        }
        return arr;
      };
      setAccessors = function() {
        var column, count, descriptor, form, i, isArray, match, pattern, type, _i, _len, _results,
          _this = this;
        pattern = /(\d*)([P|Q]*)([L|X|B|I|J|K|A|E|D|C|M]{1})/;
        _results = [];
        for (i = _i = 0, _len = tableColumns.length; _i < _len; i = ++_i) {
          column = tableColumns[i];
          form = Object.keys(column)[0];
          type = column[form];
          match = pattern.exec(form);
          count = parseInt(match[1]) || 1;
          isArray = match[2];
          descriptor = match[3];
          if (isArray) {
            switch (type) {
              case "COMPRESSED_DATA":
                _results.push((function(descriptor, count) {
                  var accessor;
                  accessor = function() {
                    var arr, pixels;
                    arr = getFromHeap(descriptor);
                    pixels = new typedArray[params["BYTEPIX"]](ztile[0]);
                    Rice(arr, params["BLOCKSIZE"], params["BYTEPIX"], pixels, ztile[0], RiceSetup);
                    return pixels;
                  };
                  return accessors.push(accessor);
                })(descriptor, count));
                break;
              case "GZIP_COMPRESSED_DATA":
                _results.push((function(descriptor, count) {
                  var accessor;
                  accessor = function() {
                    var arr;
                    arr = new Float32Array(width);
                    i = arr.length;
                    while (i--) {
                      arr[i] = NaN;
                    }
                    return arr;
                  };
                  return accessors.push(accessor);
                })(descriptor, count));
                break;
              default:
                _results.push((function(descriptor, count) {
                  var accessor;
                  accessor = function() {
                    return getFromHeap(descriptor);
                  };
                  return accessors.push(accessor);
                })(descriptor, count));
            }
          } else {
            if (count === 1) {
              _results.push((function(descriptor, count) {
                var accessor;
                accessor = function() {
                  var value, _ref;
                  _ref = dataAccessors[descriptor](view, offset), value = _ref[0], offset = _ref[1];
                  return value;
                };
                return accessors.push(accessor);
              })(descriptor, count));
            } else {
              if (descriptor === 'X') {
                _results.push((function(descriptor, count) {
                  var accessor, nBytes;
                  nBytes = Math.log(count) / Math.log(2);
                  accessor = function() {
                    var arr, bits, byte, bytes, chunk, _j, _len1;
                    chunk = view.buffer.slice(offset, offset + nBytes);
                    bytes = new Uint8Array(chunk);
                    bits = [];
                    for (_j = 0, _len1 = bytes.length; _j < _len1; _j++) {
                      byte = bytes[_j];
                      arr = _this.toBits(byte);
                      bits = bits.concat(arr);
                    }
                    offset += nBytes;
                    return bits.slice(0, +(count - 1) + 1 || 9e9);
                  };
                  return accessors.push(accessor);
                })(descriptor, count));
              } else if (descriptor === 'A') {
                _results.push((function(descriptor, count) {
                  var accessor;
                  accessor = function() {
                    var str;
                    str = view.getString(offset, count);
                    _this.offset += count;
                    return str.trim();
                  };
                  return accessors.push(accessor);
                })(descriptor, count));
              } else {
                _results.push((function(descriptor, count) {
                  var accessor;
                  accessor = function() {
                    var value, _ref;
                    data = [];
                    while (count--) {
                      _ref = dataAccessors[descriptor](view, offset), value = _ref[0], offset = _ref[1];
                      data.push(value);
                    }
                    return data;
                  };
                  return accessors.push(accessor);
                })(descriptor, count));
              }
            }
          }
        }
        return _results;
      };
      getTableRow = function() {
        var accessor, row, scale, zero, _i, _len;
        offset = rowsRead * rowByteSize;
        row = [];
        for (_i = 0, _len = accessors.length; _i < _len; _i++) {
          accessor = accessors[_i];
          row.push(accessor());
        }
        data = row[columnNames["COMPRESSED_DATA"]] || row[columnNames["UNCOMPRESSED_DATA"]] || row[columnNames["GZIP_COMPRESSED_DATA"]];
        blank = row[columnNames["ZBLANK"]] || zblank;
        scale = row[columnNames["ZSCALE"]] || bscale;
        zero = row[columnNames["ZZERO"]] || bzero;
        return [data, blank, scale, zero];
      };
      getRowHasBlanks = function(arr) {
        var i, index, scale, value, zero, _i, _len, _ref;
        _ref = getTableRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
        offset = rowsRead * width;
        for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
          value = data[index];
          i = offset + index;
          arr[i] = value === blank ? NaN : zero + scale * value;
        }
        return rowsRead += 1;
      };
      getRowNoBlanks = function(arr) {
        var i, index, scale, value, zero, _i, _len, _ref;
        _ref = getTableRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
        offset = rowsRead * width;
        for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
          value = data[index];
          i = offset + index;
          arr[i] = zero + scale * value;
        }
        return rowsRead += 1;
      };
      defGetRow = function() {
        var hasBlanks;
        hasBlanks = (zblank != null) || (blank != null) || columnNames.hasOwnProperty("ZBLANK");
        if (hasBlanks) {
          return getRowHasBlanks;
        } else {
          return getRowNoBlanks;
        }
      };
      getFrame = function() {
        var arr;
        arr = new Float32Array(width * height);
        rowsRead = 0;
        while (height--) {
          getRow(arr);
        }
        return arr;
      };
      setAccessors(tableColumns, view);
      getRow = defGetRow();
      arr = getFrame();
      data = {
        offset: offset,
        arr: arr
      };
      return postMessage(data);
    };
    fn1 = onmessage.toString().replace('return postMessage(data);', 'postMessage(data);');
    fn1 = "onmessage = " + fn1;
    fn2 = this.constructor.Rice.toString();
    fn2 = fn2.replace('function', 'function Rice');
    mime = "application/javascript";
    blobOnMessage = new Blob([fn1], {
      type: mime
    });
    blobRice = new Blob([fn2], {
      type: mime
    });
    URL = window.URL || window.webkitURL || window.MozURLProperty;
    urlOnMessage = URL.createObjectURL(blobOnMessage);
    urlRice = URL.createObjectURL(blobRice);
    worker = new Worker(urlOnMessage);
    worker.onmessage = function(e) {
      var arr;
      arr = e.data.arr;
      if (callback != null) {
        callback.call(this, arr, opts);
      }
      URL.revokeObjectURL(urlOnMessage);
      return worker.terminate();
    };
    data = {
      buffer: this.view.buffer.slice(this.begin, this.begin + this.length),
      tableLength: this.tableLength,
      tableColumns: this.tableColumns,
      columnNames: this.columnNames,
      params: this.params,
      ztile: this.ztile,
      rowByteSize: this.rowByteSize,
      zblank: this.zblank,
      bscale: this.bscale,
      bzero: this.bzero,
      width: this.width,
      height: this.height,
      blank: this.blank,
      urlRice: urlRice
    };
    return worker.postMessage(data);
  };

  HDU = (function() {

    function HDU(header, data) {
      this.header = header;
      this.data = data;
    }

    HDU.prototype.hasData = function() {
      if (this.data != null) {
        return true;
      } else {
        return false;
      }
    };

    HDU.prototype.getCard = function(key) {
      return this.header.get(key);
    };

    return HDU;

  })();

  this.astro.FITS.HDU = HDU;

  File = (function() {

    File.prototype.LINEWIDTH = 80;

    File.prototype.BLOCKLENGTH = 2880;

    function File(arg, callback, opts) {
      var xhr,
        _this = this;
      if (opts == null) {
        opts = void 0;
      }
      this.hdus = [];
      this.offset = 0;
      if (arg instanceof window.File) {
        this.initializeFromFile(arg, callback, opts);
      } else if (typeof arg === 'string') {
        this.constructor.extendDataView(this.view);
        xhr = new XMLHttpRequest();
        xhr.open('GET', arg);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function() {
          if (xhr.status !== 200) {
            if (callback != null) {
              callback.call(_this, null, opts);
            }
            return null;
          }
          return _this.initializeFromBuffer(xhr.response, callback, opts);
        };
        xhr.send();
      } else {
        this.constructor.extendDataView(this.view);
        this.initializeFromBuffer(arg);
      }
    }

    File.prototype.initializeFromBuffer = function(buffer, callback, opts) {
      var context, data, hdu, header;
      this.length = buffer.byteLength;
      this.view = new DataView(buffer);
      while (true) {
        header = this.readHeader();
        data = this.readData(header);
        hdu = new HDU(header, data);
        this.hdus.push(hdu);
        if (this.isEOF()) {
          break;
        }
      }
      context = (opts != null ? opts.context : void 0) != null ? opts.context : this;
      if (callback != null) {
        return callback.call(context, this, opts);
      }
    };

    File.prototype.initializeFromFile = function(file, callback, opts) {
      var begin, block, blockCount, end, headerStorage, offset, reader,
        _this = this;
      reader = new FileReader();
      blockCount = begin = end = offset = null;
      headerStorage = new Uint8Array();
      reader.onloadend = function(e) {
        var arr, blob, block, context, data, header, length, rowIndex, rows, s, start, tmp, value, _i, _len;
        arr = new Uint8Array(e.target.result);
        tmp = new Uint8Array(headerStorage);
        headerStorage = new Uint8Array(end);
        headerStorage.set(tmp, 0);
        headerStorage.set(arr, begin);
        rows = _this.BLOCKLENGTH / _this.LINEWIDTH;
        while (rows--) {
          rowIndex = rows * _this.LINEWIDTH;
          if (arr[rowIndex] === 32) {
            continue;
          }
          if (arr[rowIndex] === 69 && arr[rowIndex + 1] === 78 && arr[rowIndex + 2] === 68 && arr[rowIndex + 3] === 32) {
            s = '';
            for (_i = 0, _len = headerStorage.length; _i < _len; _i++) {
              value = headerStorage[_i];
              s += String.fromCharCode(value);
            }
            header = new Header(s);
            start = end + offset;
            length = header.getDataLength();
            blob = file.slice(start, start + length);
            if (header.hasDataUnit()) {
              data = _this.createDataUnit(header, blob);
            }
            _this.hdus.push(new HDU(header, data));
            offset += end + length + _this.excessBytes(length);
            if (offset === file.size) {
              context = (opts != null ? opts.context : void 0) != null ? opts.context : _this;
              if (callback != null) {
                callback.call(context, _this, opts);
              }
              return;
            }
            blockCount = 0;
            begin = blockCount * _this.BLOCKLENGTH;
            end = begin + _this.BLOCKLENGTH;
            headerStorage = new Uint8Array();
            block = file.slice(begin + offset, end + offset);
            reader.readAsArrayBuffer(block);
            return;
          }
          blockCount += 1;
          begin = blockCount * _this.BLOCKLENGTH;
          end = begin + _this.BLOCKLENGTH;
          block = file.slice(begin + offset, end + offset);
          reader.readAsArrayBuffer(block);
          return;
        }
      };
      offset = 0;
      blockCount = 0;
      begin = blockCount * this.BLOCKLENGTH;
      end = begin + this.BLOCKLENGTH;
      block = file.slice(begin + offset, end + offset);
      return reader.readAsArrayBuffer(block);
    };

    File.extendDataView = function(view) {
      DataView.prototype.getString = function(offset, length) {
        var c, value;
        value = '';
        while (length--) {
          c = this.getUint8(offset);
          offset += 1;
          value += String.fromCharCode(c > 127 ? 65533 : c);
        }
        return value;
      };
      return DataView.prototype.getChar = function(offset) {
        return this.getString(offset, 1);
      };
    };

    File.prototype.excessBytes = function(length) {
      return (this.BLOCKLENGTH - (length % this.BLOCKLENGTH)) % this.BLOCKLENGTH;
    };

    File.prototype.readHeader = function() {
      var begin, beginOffset, block, end, endOffset, endPattern, i, line, match;
      endPattern = /^END\s/;
      beginOffset = this.offset;
      while (true) {
        block = this.view.getString(this.offset, this.BLOCKLENGTH);
        this.offset += this.BLOCKLENGTH;
        i = 1;
        while (true) {
          begin = this.BLOCKLENGTH - this.LINEWIDTH * i;
          end = begin + this.LINEWIDTH;
          line = block.slice(begin, end);
          match = /\s{80}/.test(line);
          if (match) {
            i += 1;
            continue;
          }
          match = /^END\s/.test(line);
          if (match) {
            endOffset = this.offset;
            block = this.view.getString(beginOffset, endOffset - beginOffset);
            return new Header(block);
          }
          break;
        }
      }
    };

    File.prototype.createDataUnit = function(header, blob) {
      var type;
      type = header.getDataType();
      return new astro.FITS[type](header, blob);
    };

    File.prototype.readData = function(header) {
      var DU, data, excess;
      if (!header.hasDataUnit()) {
        return;
      }
      if (header.isPrimary()) {
        DU = Image;
      } else if (header.isExtension()) {
        if (header.extensionType === "BINTABLE") {
          if (header.contains("ZIMAGE")) {
            DU = CompressedImage;
          } else {
            DU = BinaryTable;
          }
        } else if (header.extensionType === "TABLE") {
          DU = Table;
        } else if (header.extensionType === "IMAGE") {
          DU = Image;
        }
      }
      data = new DU(header, this.view, this.offset);
      excess = this.excessBytes(data.length);
      this.offset += data.length + excess;
      return data;
    };

    File.prototype.isEOF = function() {
      if (this.offset === this.length) {
        return true;
      } else {
        return false;
      }
    };

    File.prototype.getHDU = function(index) {
      var hdu, _i, _len, _ref;
      if ((index != null) && (this.hdus[index] != null)) {
        return this.hdus[index];
      }
      _ref = this.hdus;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hdu = _ref[_i];
        if (hdu.hasData()) {
          return hdu;
        }
      }
    };

    File.prototype.getHeader = function(index) {
      return this.getHDU(index).header;
    };

    File.prototype.getDataUnit = function(index) {
      return this.getHDU(index).data;
    };

    File.prototype.getData = function(index) {
      return this.getHDU(index).data.getFrame();
    };

    return File;

  })();

  this.astro.FITS.File = File;

}).call(this);
